<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://lyushisyan.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lyushisyan.github.io/" rel="alternate" type="text/html" /><updated>2025-07-22T14:51:41+03:00</updated><id>https://lyushisyan.github.io/feed.xml</id><title type="html">blank</title><entry><title type="html">Thermal Conductivity Calculation using VASP + Phono3py</title><link href="https://lyushisyan.github.io/blog/2025/vasp-phono3py/" rel="alternate" type="text/html" title="Thermal Conductivity Calculation using VASP + Phono3py" /><published>2025-05-21T02:36:10+03:00</published><updated>2025-05-21T02:36:10+03:00</updated><id>https://lyushisyan.github.io/blog/2025/vasp-phono3py</id><content type="html" xml:base="https://lyushisyan.github.io/blog/2025/vasp-phono3py/"><![CDATA[<p>VASP is a first-principles simulation software.
Phono3py can calculate <strong>phonon-phonon interactions</strong> through <strong>third-order force constants</strong>. This allows the computation of lattice thermal conductivity, phonon lifetimes/linewidths, the imaginary part of self-energy (lowest-order approximation), joint density of states (JDOS), and weighted JDOS (w-JDOS).</p>

<h2 id="1-generate-displaced-supercells-poscar-files">1. Generate Displaced Supercells (<code class="language-plaintext highlighter-rouge">POSCAR</code> files)</h2>

<p>Taking diamond-structured silicon (Si) as an example, the primitive cell <code class="language-plaintext highlighter-rouge">POSCAR-unitcell</code> looks like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Si
   1.0
     5.4335600309153529    0.0000000000000000    0.0000000000000000
     0.0000000000000000    5.4335600309153529    0.0000000000000000
     0.0000000000000000    0.0000000000000000    5.4335600309153529
 Si
   8
Direct
   0.8750000000000000 0.8750000000000000 0.8750000000000000
   0.8750000000000000 0.3750000000000000 0.3750000000000000
   0.3750000000000000 0.8750000000000000 0.3750000000000000
   0.3750000000000000 0.3750000000000000 0.8750000000000000
   0.1250000000000000 0.1250000000000000 0.1250000000000000
   0.1250000000000000 0.6250000000000000 0.6250000000000000
   0.6250000000000000 0.1250000000000000 0.6250000000000000
   0.6250000000000000 0.6250000000000000 0.1250000000000000
</code></pre></div></div>

<p>Based on this unit cell, generate 2×2×2 supercells with displacements for calculating second-order (fc2) and third-order (fc3) force constants:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phono3py -d --dim 2 2 2 -c POSCAR-unitcell
</code></pre></div></div>

<p>This generates 111 displaced structures, stored in <code class="language-plaintext highlighter-rouge">phono3py_disp.yaml</code>, and creates 111 <code class="language-plaintext highlighter-rouge">POSCAR-00XXX</code> files (XXX from 000 to 110).</p>

<p>To use a larger supercell for fc2 calculation than for fc3:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phono3py -d --dim-fc2 4 4 4 --dim 2 2 2 -c POSCAR-unitcell
</code></pre></div></div>

<p>In this case, <code class="language-plaintext highlighter-rouge">POSCAR_FC2-xxxxx</code> files will also be created.</p>

<h2 id="2-run-vasp-to-calculate-forces-for-each-supercell">2. Run VASP to Calculate Forces for Each Supercell</h2>

<p>To compute the atomic forces in each displaced supercell, use the <code class="language-plaintext highlighter-rouge">POSCAR-xxxxx</code> (and <code class="language-plaintext highlighter-rouge">POSCAR_FC2-xxxxx</code> if applicable) as inputs to VASP. Each displacement supercell also requires <code class="language-plaintext highlighter-rouge">KPOINTS</code>, <code class="language-plaintext highlighter-rouge">POTCAR</code>, and <code class="language-plaintext highlighter-rouge">INCAR</code>.</p>

<p>Run each calculation in folders named <code class="language-plaintext highlighter-rouge">disp-xxxxx</code> (and <code class="language-plaintext highlighter-rouge">disp_fc2-xxxxx</code>), where xxxxx is the index. Each folder contains the input files, and the results will be saved in the <code class="language-plaintext highlighter-rouge">vasprun.xml</code> file inside that folder.</p>

<p>Use the following script to prepare input folders:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="nv">P</span><span class="o">=</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span>

<span class="k">for </span>i <span class="k">in</span> <span class="si">$(</span><span class="nb">seq</span> <span class="nt">-f</span> <span class="s2">"%05g"</span> 1 111<span class="si">)</span><span class="p">;</span> <span class="k">do
	</span><span class="nb">dir</span><span class="o">=</span><span class="s2">"disp-</span><span class="nv">$i</span><span class="s2">"</span>
	<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="s2">"</span><span class="nv">$dir</span><span class="s2">"</span>
	<span class="nb">cd</span> <span class="s2">"</span><span class="nv">$dir</span><span class="s2">"</span> <span class="o">||</span> <span class="k">continue
	</span><span class="nb">cp</span> <span class="s2">"</span><span class="nv">$P</span><span class="s2">"</span>/INCAR <span class="s2">"</span><span class="nv">$P</span><span class="s2">"</span>/KPOINTS <span class="s2">"</span><span class="nv">$P</span><span class="s2">"</span>/POTCAR <span class="nb">.</span>
	<span class="nb">cp</span> <span class="s2">"</span><span class="nv">$P</span><span class="s2">"</span>/POSCAR-<span class="s2">"</span><span class="nv">$i</span><span class="s2">"</span> POSCAR
	<span class="nb">echo</span> <span class="s2">"Prepared </span><span class="nv">$dir</span><span class="s2">"</span>
	<span class="nb">cd</span> <span class="s2">"</span><span class="nv">$P</span><span class="s2">"</span>
<span class="k">done</span>
</code></pre></div></div>

<p>Then run the VASP calculations:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="nv">P</span><span class="o">=</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span>

<span class="k">for </span>i <span class="k">in</span> <span class="si">$(</span><span class="nb">seq</span> <span class="nt">-f</span> <span class="s2">"%05g"</span> 1 111<span class="si">)</span><span class="p">;</span> <span class="k">do
    </span><span class="nv">DIR</span><span class="o">=</span><span class="s2">"</span><span class="nv">$P</span><span class="s2">/disp-</span><span class="nv">$i</span><span class="s2">"</span>
    <span class="nb">cd</span> <span class="s2">"</span><span class="nv">$DIR</span><span class="s2">"</span> <span class="o">||</span> <span class="k">continue
    </span><span class="nb">echo</span> <span class="s2">"Running disp-</span><span class="nv">$i</span><span class="s2">..."</span>

    <span class="c"># Clean old logs</span>
    <span class="nb">rm</span> <span class="nt">-f</span> OUTCAR vasprun.xml log.vasp

    <span class="c"># Run VASP and capture exit code</span>
    mpirun <span class="nt">-np</span> 16 vasp_std <span class="o">&gt;</span> log.vasp 2&gt;&amp;1
    <span class="nv">exit_code</span><span class="o">=</span><span class="nv">$?</span>

    <span class="k">if</span> <span class="o">[[</span> <span class="nv">$exit_code</span> <span class="nt">-ne</span> 0 <span class="o">]]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"❌ disp-</span><span class="nv">$i</span><span class="s2"> FAILED (exit code </span><span class="nv">$exit_code</span><span class="s2">)"</span>
    <span class="k">elif </span><span class="nb">grep</span> <span class="nt">-q</span> <span class="s2">"F= "</span> log.vasp<span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"✅ disp-</span><span class="nv">$i</span><span class="s2"> completed successfully"</span>
    <span class="k">else
        </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"⚠️  disp-</span><span class="nv">$i</span><span class="s2"> might be incomplete (check log.vasp)"</span>
    <span class="k">fi

    </span><span class="nb">cd</span> <span class="s2">"</span><span class="nv">$P</span><span class="s2">"</span>
<span class="k">done</span>
</code></pre></div></div>

<h2 id="3-collect-force-calculation-results">3. Collect Force Calculation Results</h2>

<p>To collect the force sets for fc3 and fc2, use:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phono3py <span class="nt">--cf3</span> disp-<span class="o">{</span>00001..00057<span class="o">}</span>/vasprun.xml
</code></pre></div></div>

<p>This generates the <code class="language-plaintext highlighter-rouge">FORCES_FC3</code> file.</p>

<p>If larger supercells are used for fc2, collect forces with:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phono3py <span class="nt">--cf2</span> disp_fc2-<span class="o">{</span>00001..00002<span class="o">}</span>/vasprun.xml
</code></pre></div></div>

<h2 id="4-create-fc2hdf-and-fc3hdf">4. Create <code class="language-plaintext highlighter-rouge">fc2.hdf</code> and <code class="language-plaintext highlighter-rouge">fc3.hdf</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phono3py --fc-symmetry
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">--fc-symmetry</code> option symmetrizes fc3 and fc2. This command uses <code class="language-plaintext highlighter-rouge">FORCES_FC3</code>, optionally <code class="language-plaintext highlighter-rouge">FORCES_FC2</code>, and <code class="language-plaintext highlighter-rouge">phono3py_disp.yaml</code> to generate <code class="language-plaintext highlighter-rouge">fc2.hdf5</code> and <code class="language-plaintext highlighter-rouge">fc3.hdf5</code>.</p>

<p>Although optional, using the <code class="language-plaintext highlighter-rouge">--fc3</code> and <code class="language-plaintext highlighter-rouge">--fc2</code> flags allows loading these files directly without recalculating force constants each time.</p>

<h2 id="5-thermal-conductivity-calculation">5. Thermal Conductivity Calculation</h2>

<p>A typical command for computing thermal conductivity:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phono3py --mesh 11 11 11 --br
</code></pre></div></div>

<p>This may take a long time. The <code class="language-plaintext highlighter-rouge">--thm</code> flag (tetrahedron method) is the default for Brillouin zone integration. You can alternatively use <code class="language-plaintext highlighter-rouge">--sigma</code> to specify a smearing width.</p>

<p>The above command computes phonon lifetimes serially over multiple q-points. Since each point is independent, you can parallelize across grid points:</p>

<h3 id="step-1-get-irreducible-grid-points">Step 1: Get Irreducible Grid Points</h3>

<p>First, generate irreducible q-point info with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phono3py --fc3 --fc2 --mesh 11 11 11 --br --wgp
</code></pre></div></div>

<p>This creates <code class="language-plaintext highlighter-rouge">ir_grid_points.yaml</code>. View the grid point indices with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>grep grid_point: ir_grid_points.yaml | awk '{printf("%d ", $3)}'
</code></pre></div></div>

<p>Example output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 1 2 3 4 5 12 13 14 15 16 17 18 19 20 21 24 25 26 27 28 29 30 31 36 37 38 39 40 41 48 49 50 51 60 61 148 149 150 151 160 161 162 163 164 165 172 173 174 175 184 185 297 298 309 310
</code></pre></div></div>

<h3 id="step-2-compute-phonon-lifetimes-for-subset-of-grid-points">Step 2: Compute Phonon Lifetimes for Subset of Grid Points</h3>

<p>Calculate phonon lifetimes at the first 10 irreducible q-points and store in <code class="language-plaintext highlighter-rouge">gamma</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phono3py --mesh 11 11 11 --br --write-gamma --gp 0 1 2 3 4 5 12 13 14 15
</code></pre></div></div>

<h3 id="step-3-merge-gamma-files-after-completion">Step 3: Merge Gamma Files After Completion</h3>

<p>Once all irreducible q-points (e.g., 0, 1, …, 310) are computed, merge them using:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phono3py --fc3 --fc2 --mesh 11 11 11 --br --read-gamma
</code></pre></div></div>

<p>If successful, the individual <code class="language-plaintext highlighter-rouge">.hdf5</code> files for each q-point can be safely deleted.</p>]]></content><author><name></name></author><category term="Calculation" /><summary type="html"><![CDATA[VASP is a first-principles simulation software. Phono3py can calculate phonon-phonon interactions through third-order force constants. This allows the computation of lattice thermal conductivity, phonon lifetimes/linewidths, the imaginary part of self-energy (lowest-order approximation), joint density of states (JDOS), and weighted JDOS (w-JDOS).]]></summary></entry><entry><title type="html">Training Neural-Evolution Machine Learning Potentials</title><link href="https://lyushisyan.github.io/blog/2025/nep-train/" rel="alternate" type="text/html" title="Training Neural-Evolution Machine Learning Potentials" /><published>2025-04-18T02:36:10+03:00</published><updated>2025-04-18T02:36:10+03:00</updated><id>https://lyushisyan.github.io/blog/2025/nep-train</id><content type="html" xml:base="https://lyushisyan.github.io/blog/2025/nep-train/"><![CDATA[<p>Classical interatomic potentials play a critical role in atomic simulations by enabling efficient calculation of various material properties. Machine learning-based interatomic potentials can achieve quantum-level accuracy while significantly reducing computational cost.</p>

<p>To date, a variety of machine learning models have been used to construct interatomic potentials, including:</p>

<ul>
  <li>Artificial neural networks [Phys. Rev. Lett. 98, 146401 (2007)]</li>
  <li>Gaussian regression [Phys. Rev. Lett. 104, 136403 (2010)]</li>
  <li>Linear regression [J. Comput. Phys. 285, 316 (2015)]</li>
</ul>

<p>For any model, many fitting parameters need to be determined by training on quantum mechanical data. This abundance of parameters gives machine learning potentials their superior interpolation capability over traditional empirical potentials.</p>

<p>However, finding an optimized set of parameters is not easy. Traditional training of neural network potentials relies on gradient descent, which can get trapped in local minima of the loss function and result in suboptimal solutions.</p>

<p>A better approach is based on <strong>evolutionary algorithms</strong>, a global search method. When combined with neural networks, this is referred to as <strong>neuroevolution</strong>.</p>

<p>The state-of-the-art evolutionary algorithm, <strong>separable natural evolution strategies</strong> (SNES), is particularly suitable for evolving large-scale neural networks.
[J. Mach. Learn. Res. 15, 949 (2014)]</p>

<p>Although evolutionary algorithms are less likely to get stuck in local minima, these population-based methods require many evaluations of the loss function per iteration and are usually more computationally expensive than gradient-based methods.</p>

<h2 id="1-from-coordinates-to-descriptor-vectors">1. From Coordinates to Descriptor Vectors</h2>

<p>In machine learning potentials, the site energy $U_i$ is not modeled directly as a function of relative coordinates ${\mathbf r_{ij}}$, but rather as a function of a <strong>high-dimensional descriptor vector</strong>, whose components are invariant to spatial translation, 3D rotation and inversion, and permutation of identical atoms.</p>

<p>Numerous descriptors have been proposed, such as:</p>

<ul>
  <li>Behler’s symmetry functions [J. Chem. Phys. 134, 074106 (2011)]</li>
  <li>Smooth overlap of atomic positions (SOAP) [Phys. Rev. B 87, 184115 (2013)]</li>
  <li>Bispectrum [Phys. Rev. Lett. 104, 136403 (2010)]</li>
  <li>Coulomb matrix [Phys. Rev. Lett. 108, 058301 (2012)]</li>
  <li>Moment tensor [Multiscale Model. Simul. 14, 1153 (2016)]</li>
  <li>Atomic cluster expansions [Phys. Rev. B 99, 014104 (2019)]</li>
  <li>Embedded atom descriptor [J. Phys. Chem. Lett. 10, 4962 (2019)]</li>
  <li>Gaussian moments [J. Chem. Theory Comput. 16, 5410 (2020)]</li>
  <li>Atomic permutationally invariant polynomials [Mach. Learn.: Sci. Technol. 1, 015004 (2020)]</li>
</ul>

<p>Several libraries implement these descriptors:
[Comput. Phys. Commun. 207, 310 (2016)]
[Comput. Phys. Commun. 247, 106949 (2020)]
[Mach. Learn.: Sci. Technol. 2, 027001 (2021)]</p>

<p>An overview of atomic environment descriptors can be found in: [J. Chem. Phys. 150, 154110 (2019)]</p>

<h3 id="11-single-component-systems">1.1 Single-Component Systems</h3>

<p>The following descriptors are inspired by <strong>Behler’s symmetry functions</strong> and <strong>optimized SOAP</strong>.</p>

<p>For a central atom $i$ in a single-component system, a set of <strong>radial descriptor components</strong> ($n \geq 0$) is defined as:</p>

\[q_n^i = \sum_{j\neq i} g_n(r_{ij}) \tag{1}\]

<p>And a set of <strong>angular descriptor components</strong> ($n \geq 0$ and $l \geq 1$):</p>

\[q_{nl}^i = \sum_{j\neq i}\sum_{k\neq i} g_n(r_{ij}) g_n(r_{ik}) P_l(\cos\theta_{ijk}) \tag{2}\]

<p>where $P_l(\cos\theta_{ijk})$ is the Legendre polynomial of degree $l$, and $\theta_{ijk}$ is the angle formed between bonds $ij$ and $ik$.</p>

<p>The function $g_n(r_{ij})$ is a <strong>radial function</strong>, defined using the Chebyshev polynomials of the first kind as a function of $x \equiv 2(r_{ij}/r_c − 1)^2 − 1$:</p>

\[g_n(r_{ij}) = \frac{T_n(x)+1}{2} f_c(r_{ij}) \tag{3}\]

<p>Here, $x$ ranges from -1 to 1.</p>

<p>The function $f_c(r_{ij})$ is a <strong>cutoff function</strong>:</p>

\[f_c(r_{ij}) =
\begin{cases}
(1+\cos(\pi r_{ij}/r_c))/2 &amp;\quad r\leq r_c \\
0 &amp;\quad r &gt; r_c \\
\end{cases} \tag{4}\]

<p>Note that radial functions are used in both radial and angular descriptors:</p>

<ul>
  <li>Radial components are expanded up to $n_\text{max}^\text R$, i.e., $n = 0, 1, …, n_\text{max}^\text R$</li>
  <li>Angular components are expanded up to $n_\text{max}^\text A$ in radial terms and up to $l_\text{max}$ in angular terms</li>
</ul>

<p>The dimension of the full descriptor vector is:</p>

\[N_\text{des} = (n_\text{max}^{\text R} + 1) + (n_\text{max}^{\text A} + 1) l_\text{max} \tag{5}\]

<p>Note: cutoff radii for radial and angular components can differ, denoted $r_c^\text R$ and $r_c^\text A$.</p>

<ul>
  <li>Radial components capture longer-range interactions (e.g., Coulomb and van der Waals),</li>
  <li>Angular components capture mid-range interactions.</li>
</ul>

<h3 id="12-multi-component-systems">1.2 Multi-Component Systems</h3>

<p>The above discussion omits atom species. For multi-component systems, descriptors are constructed by:</p>

<ul>
  <li>Multiplying terms in Eq. (1) with weights like $Z_j$</li>
  <li>Multiplying terms in Eq. (2) with weights like $Z_jZ_k$</li>
</ul>

<p>This method is used in the PyXtal_FF package and applies to all implemented descriptors.</p>

<p>With our definition of $g_n(r_{ij})$ in Eq. (3), the cutoff function is modified as: $f_c(r_{ij})Z_j$ or $f_c(r_{ij})\sqrt{Z_iZ_j}$.</p>

<h2 id="2-from-descriptors-to-site-energy">2. From Descriptors to Site Energy</h2>

<p>In machine learning potentials, the site energy is modeled as a function of descriptor components:</p>

\[U_i = U_i(\{q_{nl}^i\}) \tag{6}\]

<p>This is a multivariable scalar function.</p>

<p>Different machine learning models have been used to construct this function, including <strong>neural networks</strong>, <strong>Gaussian regression</strong>, and <strong>linear regression</strong>. In NEP, we choose a <strong>feedforward neural network</strong>.</p>

<p>The descriptor vector forms the input layer, and the site energy is the output layer. One or more hidden layers may lie in between.</p>

<p>Let $q_\nu^i$ be the descriptor vector (merging $n$ and $l$ into $\nu$). Let $x_\mu$ denote the hidden layer neuron states ($1 \leq \mu \leq N_\text{neu}$).</p>

<p>Then the hidden layer state is computed as:</p>

\[x_\mu = \tanh\left(\sum_{\nu=1}^{N_\text{des}} w_{\mu\nu}^{(1)} q_\nu^i - b_\mu^{(1)}\right) \tag{7}\]

<p>Here, $w_{\mu\nu}^{(1)}$ is the weight between input $\nu$ and neuron $\mu$, and $b_\mu^{(1)}$ is the bias.</p>

<p>We use the hyperbolic tangent as the activation function.</p>

<p>The output (site energy) is computed as a linear combination of hidden neurons:</p>

\[U_i = \sum_{\mu=1}^{N_\text{neu}} w_\mu^{(2)} x_\mu - b^{(2)} \tag{8}\]

<h2 id="3-training-the-machine-learning-potential">3. Training the Machine Learning Potential</h2>

<h3 id="31-defining-the-loss-function">3.1 Defining the Loss Function</h3>

<p>The goal is to determine the weights and biases that minimize a <strong>loss function</strong> measuring error between the ML-predicted quantities (energy, forces, stress) and quantum target data.</p>

<p>Let $\mathbf z$ be the vector of all network parameters, of dimension $N_\text{par}$. For a single-hidden-layer network:</p>

\[N_\text{par} = (N_\text{des}+2)N_\text{neu} + 1 \tag{9}\]

<p>The <strong>loss function</strong> $L$ is a function of $\mathbf z$:</p>

\[L = L(\mathbf z) \tag{10}\]

<p>Training becomes a <strong>real-valued optimization problem</strong>:</p>

\[\mathbf z^* = \min L(\mathbf z) \tag{11}\]

<p>Here, $\mathbf z^*$ are the optimal parameters.</p>

<p>The total loss combines several weighted terms:</p>

<ul>
  <li>Energy loss $L_\text{e}(\mathbf z)$</li>
  <li>Force loss $L_\text{f}(\mathbf z)$</li>
  <li>Stress loss $L_\text{v}(\mathbf z)$</li>
  <li>Regularization losses $L_1(\mathbf z)$ and $L_2(\mathbf z)$</li>
</ul>

<p>The total loss is:</p>

\[L(\mathbf z) = \lambda_\text{e} L_\text{e} + \lambda_\text{f} L_\text{f} + \lambda_\text{v} L_\text{v} + \lambda_1 L_1 + \lambda_2 L_2 \tag{12}\]

<ul>
  <li><strong>Energy loss</strong> (RMSE):</li>
</ul>

\[L_\text{e}(\mathbf z) = \left( \frac{1}{N_\text{str}} \sum_{n=1}^{N_\text{str}} (U^\text{NEP}(n,\mathbf z) - U^\text{tar}(n))^2 \right)^{1/2} \tag{13}\]

\[U = \sum_i U_i \tag{14}\]

<ul>
  <li><strong>Force loss</strong> (RMSE):</li>
</ul>

\[L_\text{f}(\mathbf z) = \left( \frac{1}{3N} \sum_{i=1}^{3N} (\mathbf F_i^\text{NEP} - \mathbf F_i^\text{tar})^2 \right)^{1/2} \tag{15}\]

\[\mathbf F_i = \sum_{j\neq i} \mathbf F_{ij} \tag{16}\]

\[\mathbf F_{ij} = \frac{\partial U_i}{\partial \mathbf r_{ij}} - \frac{\partial U_j}{\partial \mathbf r_{ji}} \tag{17}\]

<ul>
  <li><strong>Stress loss</strong> (RMSE):</li>
</ul>

\[L_\text{v}(\mathbf z) = \left( \frac{1}{6N_\text{str}} \sum_{n=1}^{N_\text{str}} \sum_{\mu\nu} (W^\text{NEP}_{\mu\nu}(n) - W^\text{tar}_{\mu\nu}(n))^2 \right)^{1/2} \tag{18}\]

\[\mathbf W_i = \sum_{j\neq i} \mathbf r_{ij} \otimes \frac{\partial U_j}{\partial \mathbf r_{ji}} \tag{19}\]

<ul>
  <li><strong>Regularization terms</strong>:</li>
</ul>

\[L_1(\mathbf z) = \frac{1}{N_\text{par}} \sum_{n=1}^{N_\text{par}} |z_n| \tag{20}\]

\[L_2(\mathbf z) = \left( \frac{1}{N_\text{par}} \sum_{n=1}^{N_\text{par}} z_n^2 \right)^{1/2} \tag{21}\]

<p>Regularization helps prevent overfitting by keeping weights small.</p>

<p>Recommended weights:</p>

<ul>
  <li>$\lambda_\text{e} = \lambda_\text{f} = \lambda_\text{v} = 1$ for eV/atom (energy), eV/Å (force)</li>
  <li>Tune $\lambda_1$, $\lambda_2$ for balance between overfitting and underfitting</li>
</ul>

<h3 id="32-separable-natural-evolution-strategies-as-training-algorithm">3.2 Separable Natural Evolution Strategies as Training Algorithm</h3>

<p>SNES is a derivative-free black-box optimizer that follows the <strong>natural gradient</strong> of the loss function.</p>

<p><strong>Workflow</strong>:</p>

<ol>
  <li>
    <p><strong>Initialization</strong>:
Create an initial search distribution with mean $\mathbf m$ and standard deviation $\mathbf s$ (e.g., $\mathbf m \in [-0.5, 0.5]$, $\mathbf s = 0.1$)</p>
  </li>
  <li>
    <p><strong>Iterations</strong> for $N_\text{gen}$ generations:</p>
  </li>
</ol>

<ul>
  <li>a. Generate population of candidate solutions:</li>
</ul>

\[\mathbf z_k \leftarrow \mathbf m + \mathbf s \odot \mathbf r_k \tag{22}\]

<p>where $\mathbf r_k$ is drawn from a standard normal distribution.</p>

<ul>
  <li>
    <p>b. Evaluate all $L(\mathbf z_k)$ and sort candidates</p>
  </li>
  <li>
    <p>c. Update natural gradients:</p>
  </li>
</ul>

\[\nabla_{\mathbf m} \mathbf J \leftarrow \sum_k u_k \mathbf r_k \tag{23}\]

\[\nabla_{\mathbf s} \mathbf J \leftarrow \sum_k u_k (\mathbf r_k \odot \mathbf r_k - 1) \tag{24}\]

<p>where $u_k$ are rank-based utility values.</p>

<ul>
  <li>d. Update search distribution:</li>
</ul>

\[\mathbf m \leftarrow \mathbf m + \eta_\mathbf{m} (\mathbf s \odot \nabla_{\mathbf m} \mathbf J) \tag{25}\]

\[\mathbf s \leftarrow \mathbf s + \exp\left(\frac{\eta_\mathbf{s}}{2} \nabla_{\mathbf s} \mathbf J\right) \tag{25}\]

<p>where $\eta_\mathbf{m}$ and $\eta_\mathbf{s}$ are learning rates.</p>]]></content><author><name></name></author><category term="Machine-Learning" /><summary type="html"><![CDATA[Classical interatomic potentials play a critical role in atomic simulations by enabling efficient calculation of various material properties. Machine learning-based interatomic potentials can achieve quantum-level accuracy while significantly reducing computational cost.]]></summary></entry><entry><title type="html">Landauer Theory for Electrons and Phonons</title><link href="https://lyushisyan.github.io/blog/2025/el-ph-landauer/" rel="alternate" type="text/html" title="Landauer Theory for Electrons and Phonons" /><published>2025-03-05T09:36:10+03:00</published><updated>2025-03-05T09:36:10+03:00</updated><id>https://lyushisyan.github.io/blog/2025/el-ph-landauer</id><content type="html" xml:base="https://lyushisyan.github.io/blog/2025/el-ph-landauer/"><![CDATA[<p>In nanoscale thermal transport, how to accurately describe the heat flow of electrons or phonons between two reservoirs (thermal baths) from a microscopic perspective has become a research hotspot. Landauer theory was initially proposed to analyze electron transport in quantum wires, but later this concept was extended to bosonic systems like phonons, revealing the essence of transport in nano- or micro/nano-structures.</p>

<ul>
  <li><strong>Electrons (fermions):</strong> Follow the Fermi-Dirac distribution. Each quantum state can accommodate at most two electrons (spin degeneracy). The chemical potential $\mu$ plays a key role in electron transport.</li>
  <li><strong>Phonons (bosons):</strong> Follow the Bose-Einstein distribution. Each quantum state can contain an unlimited number of phonons (no spin degeneracy, and typically $\mu = 0$).</li>
</ul>

<h2 id="1-landauer-theory-and-heat-flow-description">1. Landauer Theory and Heat Flow Description</h2>

<p>The core idea of Landauer theory in heat transport is: <strong>the transport process can be understood as quantum states being scattered or transmitted through a relatively short device region</strong>, and the upper limit of transport is determined by the number of available modes (transport channels) and the probability that these modes can transmit through the device (i.e., transmission function $\tau(\mathbf{k})$).</p>

<p>A simple physical picture is:</p>

<ul>
  <li>The device is treated as a scattering region with different distribution functions in the left and right thermal reservoirs.</li>
  <li>For a wave vector $\mathbf{k}$ with $k_x &gt; 0$, particles propagate from left to right; conversely, if $k_x &lt; 0$, they move from right to left.</li>
  <li>The net heat flow equals “left-to-right heat flow” minus “right-to-left heat flow.”</li>
</ul>

<p>The heat flux density from the left to the right reservoir (unit: W/m$^{d-1}$) is generally written as:</p>

\[J_{Q,L\to R}(T_1) = \frac{1}{L^d}\sum_p\sum_{\mathbf{k};k_x&gt;0} v_{gx,p}(\mathbf{k}) \tau_p(\mathbf{k}) [E_{i,p}(\mathbf{k}) - \mu][f_i^0(E_{i,p}(\mathbf{k}), T_1) + c_0]\]

<p>where:</p>

<ul>
  <li>$v_{gx,p}$: group velocity component in the $x$ direction;</li>
  <li>$\tau_p(\mathbf{k})$: transmission function;</li>
  <li>$E_{i,p}$: particle energy;</li>
  <li>$f_i^0$: equilibrium distribution function;</li>
  <li>$\mu$: chemical potential;</li>
  <li>$c_0$: zero-point energy correction.</li>
</ul>

<p>Similarly, the heat flow from right to left can be written, and the <strong>net heat flow</strong> is:</p>

\[J_{Q,\text{net}} = \frac{1}{L^d}\sum_p\sum_{\mathbf{k};k_x&gt;0} v_{gx,p} \tau_p [E_{i,p} - \mu][f_i^0(T_1) - f_i^0(T_2)]\]

<p>Note that the zero-point energy $c_0$ cancels out in the net heat flow and thus has no net contribution.</p>

<h2 id="2-from-k-space-summation-to-integral-form">2. From k-Space Summation to Integral Form</h2>

<p>For better analysis, the k-space summation is often converted into an integral (Landauer integral). The forms differ with dimensionality:</p>

<h3 id="1d-system">1D System:</h3>

\[J_{Q,\text{net}} = \sum_p \int_0^\infty \frac{v_{g,p} \tau_p [E_{i,p}(k) - \mu]}{2\pi} [f_i^0(T_1) - f_i^0(T_2)] dk\]

<h3 id="2d-system">2D System:</h3>

\[J_{Q,\text{net}} = \sum_p\int_{-\pi/2}^{\pi/2}\int_0^\infty\frac{v_{g,p}\cos\theta\tau_p [E_{i,p}(k)-\mu]}{4\pi^2}[f_i^0(T_1)-f_i^0(T_2)]kdkd\theta\]

\[= \frac{1}{2\pi^2}\sum_p\int_0^\infty v_{g,p}\tau_p [E_{i,p}(k)-\mu] [f_i^0(T_1)-f_i^0(T_2)]kdk\]

<h3 id="3d-system">3D System:</h3>

\[J_{Q,\text{net}} = \sum_p\int_0^{2\pi}\int_{0}^{\pi/2}\int_0^\infty\frac{v_{g,p}\cos\theta\tau_p [E_{i,p}(k)-\mu]}{8\pi^3} [f_i^0(T_1)-f_i^0(T_2)]k^2dk\sin\theta d\theta d\varphi\]

\[= \frac{1}{8\pi^2}\sum_p\int_0^\infty v_{g,p}\tau_p [E_{i,p}(k)-\mu] [f_i^0(T_1)-f_i^0(T_2)]k^2dk\]

<p>Angle $\theta$ denotes the angle between the wave vector and the transport direction $x$. It’s often assumed that $\tau$ is direction-independent.</p>

<p>By introducing the density of states (DOS), the k-space integral can be converted into an integral over frequency $\omega$ or energy $E$.</p>

<h3 id="for-phonons">For Phonons:</h3>

<p>Using frequency DOS $D(\omega)$ and $E = \hbar\omega$ with $\mu = 0$:</p>

<ul>
  <li><strong>1D:</strong></li>
</ul>

\[J_{Q,\text{ph}} = \frac{1}{2} \sum_p \int_0^\infty v_{g,p} D_{\text{1D}}(\omega) \tau_p(\omega) \hbar\omega [f_{\text{BE}}^0(T_1) - f_{\text{BE}}^0(T_2)] d\omega\]

<ul>
  <li><strong>2D:</strong></li>
</ul>

\[J_{Q,\text{ph}} = \frac{1}{\pi} \sum_p \int_0^\infty v_{g,p} D_{\text{2D}}(\omega) \tau_p(\omega) \hbar\omega [f_{\text{BE}}^0(T_1) - f_{\text{BE}}^0(T_2)] d\omega\]

<ul>
  <li><strong>3D:</strong></li>
</ul>

\[J_{Q,\text{ph}} = \frac{1}{4} \sum_p \int_0^\infty v_{g,p} D_{\text{3D}}(\omega) \tau_p(\omega) \hbar\omega [f_{\text{BE}}^0(T_1) - f_{\text{BE}}^0(T_2)] d\omega\]

<h3 id="for-electrons">For Electrons:</h3>

<p>With nonzero chemical potential $\mu$ and energy DOS $D(E)$:</p>

<ul>
  <li><strong>1D:</strong></li>
</ul>

\[J_{Q,\text{el}} = \frac{1}{2} \sum_p \int_0^\infty v_{g,p} D_{\text{1D}}(E) \tau_p(E) (E - \mu) [f_{\text{FD}}^0(T_1) - f_{\text{FD}}^0(T_2)] dE\]

<ul>
  <li><strong>2D:</strong></li>
</ul>

\[J_{Q,\text{el}} = \frac{1}{\pi} \sum_p \int_0^\infty v_{g,p} D_{\text{2D}}(E) \tau_p(E) (E - \mu) [f_{\text{FD}}^0(T_1) - f_{\text{FD}}^0(T_2)] dE\]

<ul>
  <li><strong>3D:</strong></li>
</ul>

\[J_{Q,\text{el}} = \frac{1}{4} \sum_p \int_0^\infty v_{g,p} D_{\text{3D}}(E) \tau_p(E) (E - \mu) [f_{\text{FD}}^0(T_1) - f_{\text{FD}}^0(T_2)] dE\]

<h2 id="3-number-of-modes-and-half-wavelength-interpretation">3. Number of Modes and Half-Wavelength Interpretation</h2>

<p>To combine quantitative analysis with intuitive understanding, the Landauer theory introduces the concept of <strong>number of modes</strong>.</p>

<p>This idea can also be used to analyze <strong>heat flow</strong> $Q$ (in watts), which is the product of <strong>heat flux density</strong> $J_Q$ and “cross-sectional area”:</p>

<ul>
  <li>For 1D: the area is 1 (or ignored);</li>
  <li>For 2D: the area is the contact width $W$;</li>
  <li>For 3D: the area is the contact cross-sectional area $A$.</li>
</ul>

<h3 id="31-general-expression-for-phonon-heat-flow">3.1 General Expression for Phonon Heat Flow</h3>

<p>For phonons, the general expression for heat flow (or thermal power) is:</p>

\[Q_{\text{ph}} = \frac{1}{2\pi} \int_0^\infty M(\omega)\tau(\omega)\hbar\omega [f_\text{BE}^0(T_1) - f_\text{BE}^0(T_2)]\,d\omega\]

<p>where:</p>

<ul>
  <li>$M(\omega)$ is the <strong>number of modes</strong>, representing the number of half-wavelengths (λ/2) of phonons per unit cross-sectional area at frequency $\omega$;</li>
  <li>$\tau(\omega)$ is the transmission function;</li>
  <li>$f_\text{BE}^0$ is the Bose-Einstein distribution function.</li>
</ul>

<h3 id="32-number-of-modes-in-different-dimensions">3.2 Number of Modes in Different Dimensions</h3>

<p>The number of modes varies with dimensionality:</p>

<ul>
  <li><strong>1D:</strong></li>
</ul>

\[M(\omega) = M_{\text{1D}}(\omega)\]

<ul>
  <li><strong>2D:</strong></li>
</ul>

\[M(\omega) = W \cdot M_{\text{2D}}(\omega)\]

<ul>
  <li><strong>3D:</strong></li>
</ul>

\[M(\omega) = A \cdot M_{\text{3D}}(\omega)\]

<p>By comparing the relations $J_Q(1D)=Q$, $J_Q(2D)=Q/W$, $J_Q(3D)=Q/A$ with the expressions for heat flux density, we can derive the relationship between mode density $M(\omega)$ and density of states $D(\omega)$:</p>

\[M_{\text{1D}}(\omega) = 1 = \pi v_g(\omega) D_{\text{1D}}(\omega)\]

\[M_{\text{2D}}(\omega) = \frac{K(\omega)}{\pi} = \pi \cdot \frac{2v_g(\omega)}{\pi} D_{\text{2D}}(\omega)\]

\[M_{\text{3D}}(\omega) = \frac{K^2(\omega)}{4\pi} = \pi \cdot \frac{v_g(\omega)}{2} D_{\text{3D}}(\omega)\]

<p>Here, $v_g(\omega)$ is the group velocity, and $K(\omega)$ is the wave vector magnitude.</p>

<p>We know the <strong>phonon DOS</strong> is:</p>

\[D_{\text{1D}}(\omega) = \frac{1}{\pi v_g(\omega)}\]

\[D_{\text{2D}}(\omega) = \frac{K(\omega)}{2\pi v_g(\omega)}\]

\[D_{\text{3D}}(\omega) = \frac{K^2(\omega)}{2\pi^2 v_g(\omega)}\]

<p>Substituting these into the expressions for number of modes:</p>

\[M_{\text{1D}}(\omega) = \pi v_g(\omega) \cdot \frac{1}{\pi v_g(\omega)} = 1\]

\[M_{\text{2D}}(\omega) = W \cdot \pi \cdot \left[ \frac{2v_g(\omega)}{\pi} \right] \cdot \frac{K(\omega)}{2\pi v_g(\omega)}\]

\[M_{\text{3D}}(\omega) = A \cdot \pi \cdot \left[ \frac{v_g(\omega)}{2} \right] \cdot \frac{K^2(\omega)}{2\pi^2 v_g(\omega)}\]

<h3 id="33-physical-meaning-of-spatially-averaged-group-velocity">3.3 Physical Meaning of Spatially Averaged Group Velocity</h3>

<p>The terms in square brackets above represent the <strong>spatially averaged x-direction group velocity</strong> at a given frequency:</p>

<ul>
  <li><strong>1D</strong>: Only motion along x-direction, so the average is $v_g$ itself;</li>
  <li><strong>2D</strong>: Average of $\cos\theta$ over a semicircle is $2/\pi$, thus $\langle v_{gx} \rangle = 2v_g/\pi$;</li>
  <li><strong>3D</strong>: Average of $\cos\theta$ over a hemisphere is $1/2$, thus $\langle v_{gx} \rangle = v_g/2$.</li>
</ul>

<h3 id="34-geometric-interpretation-using-half-wavelength">3.4 Geometric Interpretation Using Half-Wavelength</h3>

<p>The number of modes $M(\omega)$ can also be interpreted geometrically as the number of half-wavelengths fitting into the cross-section:</p>

<ul>
  <li>In <strong>1D</strong>, there’s only 1 propagating mode per frequency;</li>
  <li>In <strong>2D</strong>, the contact width $W$ can be divided into half-wavelength sections;</li>
  <li>In <strong>3D</strong>, the contact area $A$ is filled with these half-wave units.</li>
</ul>

\[(\text{1D}) :\quad M(\omega)=1\]

\[(\text{2D}) :\quad M(\omega) = \frac{W}{\lambda/2}\]

\[(\text{3D}) :\quad M(\omega) = \frac{A}{4/\pi(\lambda/2)^2}\]

<h3 id="35-similar-analysis-for-electrons">3.5 Similar Analysis for Electrons</h3>

<p>For electrons, a similar analysis gives the energy-integrated thermal flow as:</p>

\[Q_{\text{el}} = \frac{1}{\pi\hbar} \int_0^\infty M(E) \tau(E)(E - \mu)[f_\text{FD}^0(T_1) - f_\text{FD}^0(T_2)]\,dE\]

<p>According to Lundstrom and Jeong (2013), for electrons with a parabolic band, the number of modes is:</p>

\[(\text{1D}) :\quad M_\text{1D}(E) = H(E - E_c)\]

\[(\text{2D}) :\quad M(E) = W \cdot g_v \cdot \frac{\sqrt{2m^*(E - E_c)}}{\pi\hbar} \cdot H(E - E_c)\]

\[(\text{3D}) :\quad M(E) = A \cdot g_v \cdot \frac{m^*(E - E_c)}{2\pi\hbar^2} \cdot H(E - E_c)\]

<p>Where:</p>

<ul>
  <li>$H(E - E_c)$ is the Heaviside function (only electrons above the conduction band minimum contribute);</li>
  <li>$g_v$ is valley degeneracy;</li>
  <li>$m^*$ is the effective mass;</li>
  <li>$E_c$ is the conduction band minimum.</li>
</ul>

<hr />

<h2 id="4-thermal-conductance-and-spectral-conductance">4. Thermal Conductance and Spectral Conductance</h2>

<h3 id="41-thermal-conductance">4.1 Thermal Conductance</h3>

<p><strong>Thermal conductance</strong> $G_Q$ is defined as heat flow per unit temperature difference:</p>

\[G_Q = \frac{Q}{T_1 - T_2}\]

<p>For small temperature differences, the differential form is:</p>

\[G_Q(T) = \frac{Q(T + \delta T/2, T - \delta T/2)}{\delta T}\]

<h4 id="for-phonons-1">For Phonons:</h4>

\[G_Q(T) = \frac{1}{2\pi} \int_0^\infty M(\omega) \tau(\omega) \hbar\omega \frac{\partial f_\text{BE}^0}{\partial T} \, d\omega\]

<h4 id="for-electrons-1">For Electrons:</h4>

\[G_Q(T) = \frac{1}{\pi\hbar} \int_0^\infty M(E) \tau(E) (E - \mu) \frac{\partial f_\text{FD}^0}{\partial T} \, dE\]

<p>Here, $M$ is the number of modes, $\tau$ is the transmission function, and $f^0$ is the equilibrium distribution.</p>

<h3 id="42-spectral-conductance">4.2 Spectral Conductance</h3>

<p>The integrand of $G_Q$ represents the <strong>contribution to thermal conductance at each frequency or energy</strong>, known as the <strong>spectral conductance</strong> $G_Q’$:</p>

<ul>
  <li><strong>For Phonons:</strong></li>
</ul>

\[G_Q'(\omega, T) = \frac{1}{2\pi} M(\omega) \tau(\omega) \hbar\omega \frac{\partial f_\text{BE}^0}{\partial T}\]

<ul>
  <li><strong>For Electrons:</strong></li>
</ul>

\[G_Q'(E, T) = \frac{1}{\pi\hbar} M(E) \tau(E) (E - \mu) \frac{\partial f_\text{FD}^0}{\partial T}\]

<p>These functions show that the energy transport capacity depends on both the number of available modes $M$ and the thermal sensitivity $\partial f / \partial T$.</p>

<p>To simplify analysis, one can define a <strong>normalized spectral conductance</strong> by dividing out constants like $k_B$, $M$, and assuming <strong>ideal transmission</strong> $\tau = 1$:</p>

\[\tilde G_Q' = \frac{G_Q'}{C_0k_BM\tau} = (f_i^0)^2e^xx^2\]

<p>with $x = \hbar\omega / k_B T$ as the dimensionless energy.</p>

<p>In the <strong>phonon case</strong>, for low-frequency modes, the normalized conductance approaches 1 — indicating that <strong>each mode contributes equally</strong> at low frequencies, until the energy exceeds thermal energy $k_BT$.</p>

<p>In the <strong>electron case</strong>, low-energy modes contribute little due to the <strong>Pauli exclusion principle</strong>: electrons must be thermally excited across the Fermi level, so most contribution comes from states near $E \approx \mu$.</p>]]></content><author><name></name></author><category term="Physics" /><summary type="html"><![CDATA[In nanoscale thermal transport, how to accurately describe the heat flow of electrons or phonons between two reservoirs (thermal baths) from a microscopic perspective has become a research hotspot. Landauer theory was initially proposed to analyze electron transport in quantum wires, but later this concept was extended to bosonic systems like phonons, revealing the essence of transport in nano- or micro/nano-structures.]]></summary></entry><entry><title type="html">First-Principles-Based PBTE Method</title><link href="https://lyushisyan.github.io/blog/2025/abinitio-bte/" rel="alternate" type="text/html" title="First-Principles-Based PBTE Method" /><published>2025-02-16T09:36:10+03:00</published><updated>2025-02-16T09:36:10+03:00</updated><id>https://lyushisyan.github.io/blog/2025/abinitio-bte</id><content type="html" xml:base="https://lyushisyan.github.io/blog/2025/abinitio-bte/"><![CDATA[<p>In microscale and nanoscale heat conduction, size effects mainly involve two key length scales: <strong>phonon wavelength</strong> and <strong>mean free path (MFP)</strong>.</p>

<ul>
  <li>If the system’s characteristic size is much larger than the phonon MFP, heat conduction is in the <strong>macroscopic diffusive regime</strong>, and the classical heat diffusion equation is applicable.</li>
  <li>If the size is comparable to the phonon MFP, <strong>classical size effects</strong> and <strong>ballistic phonon transport</strong> must be considered. In this case, the <strong>Boltzmann Transport Equation (BTE)</strong> should be used to describe energy transport.</li>
  <li>If the size further shrinks to the scale of the phonon wavelength, <strong>wave characteristics of phonons</strong> become important.</li>
</ul>

<p>The <strong>First-Principles Phonon Boltzmann Transport Equation (PBTE)</strong> method is essentially a combination of the following three techniques:</p>

<ul>
  <li><strong>First-principles method (ab initio method)</strong>: A numerical method for solving the <strong>Schrödinger equation</strong>.</li>
  <li><strong>Lattice dynamics method</strong>: A method to compute phonon dispersion and relaxation times based on interatomic force constants (IFCs).</li>
  <li><strong>Boltzmann Transport Equation (BTE)</strong>: A heat transport model that uses phonon dispersion and relaxation time as inputs to calculate the system’s total thermal conductivity.</li>
</ul>

<h2 id="1-first-principles-methods">1. First-Principles Methods</h2>

<p>First-principles (ab initio) methods refer to techniques that solve the electronic structure and atomic interactions of materials within the framework of quantum mechanics, using <strong>minimal empirical parameters</strong>. They are primarily based on numerical solutions to the Schrödinger equation, yielding properties such as ground-state electron density, band structure, total energy, and other physical quantities.
In solid-state physics and materials science, first-principles methods are typically based on <strong>Density Functional Theory (DFT)</strong>. As the full many-body Schrödinger equation is difficult to solve directly, DFT provides an efficient way to handle many-body problems via the electron density and is widely applied to metals, semiconductors, insulators, molecules, and surfaces.</p>

<h3 id="11-basic-concept-of-density-functional-theory">1.1 Basic Concept of Density Functional Theory</h3>

<p>The core concepts of DFT originate from the Hohenberg-Kohn theorem and the Kohn-Sham equation:</p>

<ol>
  <li>The <strong>Hohenberg-Kohn theorem</strong> states that all ground-state physical quantities of a system are functionals of the electron density $\rho(\mathbf{r})$, i.e., the Hamiltonian and energy of the system are uniquely determined by the electron density.</li>
  <li>The <strong>Kohn-Sham equation</strong> maps the real many-electron system to an auxiliary system of non-interacting electrons, using an appropriate <strong>exchange-correlation potential</strong> to approximate electron–electron interactions. The multi-body problem thus becomes solving a set of single-particle-like equations:</li>
</ol>

\[\left[ -\frac{\hbar^2}{2m}\nabla^2 + V_\text{ext}(\mathbf{r}) + V_\text{H}(\mathbf{r}) + V_\text{xc}(\mathbf{r}) \right] \phi_i(\mathbf{r}) = \epsilon_i \phi_i(\mathbf{r})\]

<p>Where:</p>

<ul>
  <li>$V_\text{ext}(\mathbf{r})$: Coulomb potential from atomic nuclei</li>
  <li>$V_\text{H}(\mathbf{r})$: classical Hartree potential</li>
  <li>$V_\text{xc}(\mathbf{r})$: exchange-correlation potential that includes all complex many-body effects</li>
</ul>

<p>In practice, one must choose an exchange-correlation functional (e.g., LDA, GGA, or hybrid functionals) and adopt a method to treat real and reciprocal space (e.g., pseudopotentials, PAW, APW+lo, etc.).</p>

<h3 id="12-obtaining-interatomic-force-constants-ifcs-from-dft">1.2 Obtaining Interatomic Force Constants (IFCs) from DFT</h3>

<p>A crucial step in thermal conductivity calculations is determining the <strong>interatomic force constants (IFCs)</strong> of the material. These constants are used to construct the dynamical matrix and calculate lattice dynamical properties such as phonon dispersion and phonon lifetimes. IFCs can be obtained from first-principles calculations using two main methods:</p>

<h4 id="121-density-functional-perturbation-theory-dfpt">1.2.1 Density Functional Perturbation Theory (DFPT)</h4>

<p>In the DFPT framework, small periodic perturbations are applied to the periodic structure, and the linearized Kohn-Sham equations are solved to obtain the first-, second-, or third-order responses of the potential energy with respect to atomic displacements.</p>

<ul>
  <li>DFPT can directly calculate IFCs and phonon modes in $\mathbf{q}$-space.</li>
  <li>Both second-order (harmonic) and third-order (anharmonic) IFCs can be obtained for phonon dispersion and scattering analysis.</li>
</ul>

<h4 id="122-finite-displacement-method-fdm">1.2.2 Finite Displacement Method (FDM)</h4>

<p>In this method, small displacements (e.g., 0.01 Å) are applied to atoms in a supercell, and the resulting changes in energy or forces are used to compute second-order and higher-order IFCs:</p>

<ul>
  <li>A sufficiently large supercell is required to ensure negligible interaction across boundaries.</li>
  <li>Multiple configurations with different displacements must be computed to extract complete IFCs.</li>
</ul>

<p>Both methods rely on DFT-level force or energy calculations. Since phonon properties are sensitive to calculation accuracy, careful choices of exchange-correlation functional, plane-wave cutoff energy, and k-point mesh are necessary to ensure accurate IFCs.</p>

<h2 id="2-harmonic-and-anharmonic-lattice-dynamics">2. Harmonic and Anharmonic Lattice Dynamics</h2>

<p>In <strong>harmonic lattice dynamics</strong>, the second-order IFCs are used to obtain the phonon dispersion relation $\omega_\lambda(\mathbf{q})$. Once dispersion is known, specific heat of each phonon mode $\lambda$ can be computed.
The phonon group velocity is defined as the gradient of the frequency with respect to wave vector: $\mathbf{v}<em>\lambda = \nabla</em>\mathbf{q} \omega_\lambda$
The <strong>relaxation time</strong> $\tau_\lambda$ is obtained through <strong>anharmonic lattice dynamics</strong>, which involves both second- and higher-order IFCs.</p>

<h3 id="21-dispersion-relation">2.1 Dispersion Relation</h3>

<p>For a periodic crystal with small displacements around equilibrium, the total potential energy $U$ can be expanded as a Taylor series:</p>

\[U = U_0 + \frac{1}{2!} \sum_{ij}\sum_{\alpha\beta} \Phi_{ij}^{\alpha\beta} u_i^\alpha u_j^\beta + \frac{1}{3!} \sum_{ijk}\sum_{\alpha\beta\gamma} \Psi_{ijk}^{\alpha\beta\gamma} u_i^\alpha u_j^\beta u_k^\gamma + \mathcal{O}(u^4)\]

<p>Where:</p>

<ul>
  <li>$U_0$: potential energy at equilibrium</li>
  <li>$u_{i}^\alpha$: displacement of atom $i$ in direction $\alpha$</li>
  <li>$\Phi_{ij}^{\alpha\beta}$: second-order IFCs (harmonic)</li>
  <li>$\Psi_{ijk}^{\alpha\beta\gamma}$: third-order IFCs (anharmonic)</li>
  <li>$\mathcal{O}(u^4)$: higher-order terms</li>
</ul>

<p>Due to force equilibrium, first-order terms are absent. Neglecting higher-order terms leads to the harmonic approximation.</p>

<p>If atom $i$ belongs to the $b$-th atom in the $l$-th unit cell and $j$ is in the $l’$-th cell, the equation of motion becomes:</p>

\[m_b\frac{d^2 u_{lb}^\alpha (t)}{d t^2} = -\sum_{l'b',\beta} \Phi_{lb,l'b'}^{\alpha\beta} u_{l'b'}^{\beta} (t)\]

<p>Assuming plane wave solutions:</p>

\[u_{lb}^\alpha (t) = \frac{1}{\sqrt{m_b}}\Lambda_\lambda e_{b,\lambda}^\alpha e^{i(\mathbf q\cdot\mathbf R_l - \omega_\lambda t)}\]

<p>Substituting gives the eigenvalue equation:</p>

\[\omega_\lambda^2 \mathbf e _{b,\lambda} = \mathbf D_{bb'}^{\alpha\beta}(\textbf q) \textbf e_{b,\lambda}\]

<p>Where the <strong>dynamical matrix</strong> is:</p>

\[\mathbf D_{bb'}^{\alpha\beta}(\textbf q) =\frac{1}{\sqrt{m_bm_{b'}}}\sum_{l'}\Phi_{0b,l'b'}^{\alpha\beta} e^{i\mathbf q\cdot(\mathbf R_{l'} - \mathbf R_0)}\]

<p>Solving gives the phonon dispersion $\omega_\lambda(\mathbf{q})$ and corresponding eigenvectors ${e_{b,\lambda}^\alpha}$.</p>

<h3 id="22-phonon-scattering-mechanisms-and-relaxation-time">2.2 Phonon Scattering Mechanisms and Relaxation Time</h3>

<p>In real materials, phonons have finite lifetimes due to various scattering mechanisms. Within the BTE framework, these are expressed as <strong>scattering rates</strong> $\Gamma_\lambda$ or equivalently <strong>relaxation times</strong> $\tau_\lambda$.</p>

<h4 id="221-phonon-phonon-scattering">2.2.1 Phonon-Phonon Scattering</h4>

<p>In nonmetals, the dominant scattering is <strong>phonon-phonon interactions</strong>, i.e., anharmonic lattice effects. Quantum mechanically, the crystal Hamiltonian is divided into harmonic and anharmonic parts.
Third-order scattering (three-phonon processes) includes combination and splitting processes. Energy and momentum conservation must be satisfied (including Umklapp processes):</p>

\[\Gamma_{\lambda\lambda'\lambda''}^{\pm} = \frac{\hbar\pi}{4}\begin{Bmatrix}n_{\lambda'}-n_{\lambda''} \\ n_{\lambda'} + n_{\lambda''}+1 \end{Bmatrix} \frac{\delta(\omega_\lambda\pm\omega_{\lambda'} - \omega_{\lambda''})}{\omega_{\lambda}\omega_{\lambda'}\omega_{\lambda''}}|V_{\lambda\lambda'\lambda''}^{\pm}|^2\Delta_{\mathbf{G}, \,\mathbf{q}\pm \mathbf{q}' - \mathbf{q}''}\]

<h4 id="222-phonon-impurity-scattering">2.2.2 Phonon-Impurity Scattering</h4>

<p>Caused by mass or bonding perturbations from impurities (e.g., isotopes, defects):</p>

\[\Gamma_{\lambda\lambda'} = \frac{\pi \omega_\lambda^2}{2}\delta(\omega_\lambda - \omega_{\lambda'})\sum_bg(b) |\mathbf e_{b,\lambda}^*\cdot \mathbf e_{b,\lambda'}|^2\]

<p>Where $g(b) = \sum_s f_s(b)(1 - \frac{m_{b,s}}{\overline{m}_b})^2$ and $\overline{m}<em>b = \sum_s f_s(b) m</em>{b,s}$.</p>

<h2 id="3-thermal-conductivity-and-the-boltzmann-transport-equation-bte">3. Thermal Conductivity and the Boltzmann Transport Equation (BTE)</h2>

<h3 id="31-thermal-conductivity">3.1 Thermal Conductivity</h3>

<p>According to Fourier’s law, the thermal conductivity $\kappa$ characterizes the ability of a material to conduct heat:</p>

\[\mathbf{J} = -\kappa \nabla T\]

<p>Where $\mathbf{J}$ is the heat flux vector and $\nabla T$ is the temperature gradient. In anisotropic materials, $\kappa$ is a tensor.</p>

<p>To predict $\kappa$ from phonon properties, one must use the BTE to describe the non-equilibrium phonon distribution under a small temperature gradient. Assuming steady-state and small gradients, the linearized BTE is:</p>

\[-\mathbf{v}_\lambda \nabla T \frac{\partial n_\lambda^0}{\partial T} = \frac{n_\lambda'}{\tau_\lambda}\]

<p>Where:</p>

<ul>
  <li>$n_\lambda = n_\lambda^0 + n_\lambda’$ is the phonon distribution</li>
  <li>$n_\lambda^0$ is the equilibrium Bose–Einstein distribution</li>
  <li>$n_\lambda’$ is the perturbation from equilibrium</li>
  <li>$\tau_\lambda$ is the relaxation time</li>
  <li>$\mathbf{v}_\lambda$ is the group velocity of mode $\lambda$</li>
</ul>

<p>The Bose–Einstein distribution:</p>

\[n_\lambda^0 = \frac{1}{\exp\left(\frac{\hbar \omega_\lambda}{k_B T}\right) - 1}\]

<p>The heat flux contributed by phonons:</p>

\[\mathbf{J} = \frac{1}{V} \sum_\lambda \hbar\omega_\lambda \mathbf{v}_\lambda n_\lambda\]

<p>Where $V = N_0 \cdot \Omega$ is the total volume ($\Omega$ = unit cell volume, $N_0$ = number of $\mathbf{q}$-points). Comparing with Fourier’s law gives the thermal conductivity tensor:</p>

\[\kappa^{\alpha\beta} = \frac{1}{V}\sum_\lambda \hbar\omega_\lambda \frac{\partial n_\lambda^0}{\partial T} v_\lambda^\alpha v_\lambda^\beta \tau_\lambda = \sum_\lambda c_\lambda v_\lambda^\alpha v_\lambda^\beta \tau_\lambda\]

<p>Where $c_\lambda = \frac{\hbar\omega_\lambda}{V}\frac{\partial n_\lambda^0}{\partial T}$ is the mode heat capacity.
For isotropic systems:</p>

\[\kappa = \frac{1}{3V}\sum_\lambda \hbar\omega_\lambda \frac{\partial n_\lambda^0}{\partial T} |\mathbf{v}_\lambda|^2 \tau_\lambda\]

<h3 id="32-single-mode-relaxation-time-approximation-smrta">3.2 Single-Mode Relaxation Time Approximation (SMRTA)</h3>

<p>The SMRTA assumes that all phonon modes except mode $\lambda$ remain in equilibrium:</p>

\[\begin{cases}
n_\lambda = n_\lambda^0 + n_\lambda' \\
n_{\lambda'} = n_{\lambda'}^0 \\
n_{\lambda''} = n_{\lambda''}^0
\end{cases}\]

<p>The SMRTA relaxation time becomes:</p>

\[\frac{1}{\tau_\lambda^0} = \sum_{\lambda'\lambda''}^+ \Gamma_{\lambda\lambda'\lambda''}^+ + \sum_{\lambda'\lambda''}^- \frac{1}{2} \Gamma_{\lambda\lambda'\lambda''}^- + \sum_{\lambda'}\Gamma_{\lambda\lambda'}\]

<p>Where superscript 0 indicates this is the zero-order approximation.</p>

<h3 id="33-iterative-solution">3.3 Iterative Solution</h3>

<p>To overcome SMRTA limitations, the <strong>Full Iterative Method</strong> solves the BTE self-consistently:</p>

\[\begin{cases}
n_\lambda = n_\lambda^0 + n_\lambda' \\
n_{\lambda'} = n_{\lambda'}^0 + n_{\lambda'}' \\
n_{\lambda''} = n_{\lambda''}^0 + n_{\lambda''}'
\end{cases}\]

<p><strong>Initial Guess</strong>:
Use $\tau_\lambda^0$ from SMRTA.</p>

<p><strong>Self-Consistent Iteration</strong>:
Form a coupled system of equations for all $n_\lambda’$ and iterate until convergence.</p>

<p>The relaxation time becomes:</p>

\[\tau_\lambda = \tau_\lambda^0 + \tau_\lambda^0 \Delta_\lambda\]

\[\Delta_\lambda = \sum_{\lambda'\lambda''}^+ \Gamma_{\lambda\lambda'\lambda''}^+ (\xi_{\lambda\lambda''}\tau_{\lambda''} - \xi_{\lambda\lambda'}\tau_{\lambda'}) \\ + \sum_{\lambda'\lambda''}^- \frac{1}{2} \Gamma_{\lambda\lambda'\lambda''}^-(\xi_{\lambda\lambda''}\tau_{\lambda''} + \xi_{\lambda\lambda'}\tau_{\lambda'}) \\+ \sum_{\lambda'}\Gamma_{\lambda\lambda'}\xi_{\lambda\lambda'}\tau_{\lambda'}\]

<p>This method includes more detailed interactions and better captures <strong>phonon redistribution</strong> caused by <strong>Normal processes</strong>, especially in high thermal conductivity or low-temperature systems. However, it is also more computationally intensive.</p>

<h2 id="4-computational-workflow-and-software">4. Computational Workflow and Software</h2>

<p>The general workflow for calculating phonon thermal conductivity includes:</p>

<h3 id="1-extract-interatomic-force-constants-ifcs">(1) Extract Interatomic Force Constants (IFCs)</h3>

<p>IFCs are the basis for lattice dynamics and thermal transport. They can be obtained via:</p>

<ul>
  <li><strong>Classical potentials</strong>: for simple structures with known potentials</li>
  <li><strong>Machine learning potentials (MLPs)</strong>: recent development balancing accuracy and efficiency</li>
  <li><strong>First-principles (DFT)</strong>: most common and accurate method without empirical parameters</li>
</ul>

<p>Two main extraction methods:</p>

<ul>
  <li><strong>Finite Displacement Method</strong>: Apply small displacements in supercells and use numerical derivatives to obtain IFCs (supports classical/ML/DFT).</li>
  <li><strong>DFPT</strong>: Perturbative method within DFT framework; directly computes IFCs in reciprocal space.</li>
</ul>

<h3 id="2-truncation-and-symmetry-correction">(2) Truncation and Symmetry Correction</h3>

<p>IFCs theoretically exist between all atomic pairs. In practice, a <strong>cutoff radius</strong> is applied. The impact of different cutoffs should be tested.</p>

<p>Also, due to numerical noise and truncation, computed IFCs may violate <strong>translational invariance</strong> or crystal symmetry. These must be corrected to ensure accurate thermal conductivity.</p>

<h3 id="3-compute-thermal-conductivity">(3) Compute Thermal Conductivity</h3>

<p>With second- and third-order IFCs, combine <strong>anharmonic lattice dynamics</strong> and <strong>BTE</strong> using:</p>

<ul>
  <li><strong>SMRTA</strong>: fast estimation</li>
  <li><strong>Full Iterative Solution</strong>: more accurate, especially for high-κ or low-T systems</li>
</ul>

<p>This method requires <strong>no fitting parameters</strong>, only the initial atomic structure. It is highly predictive and widely validated against experiments.</p>

<h3 id="4-numerical-error-and-applicability">(4) Numerical Error and Applicability</h3>

<p>Despite its strength, this method is still sensitive to:</p>

<ul>
  <li>DFT convergence, functional choice, and displacement size</li>
  <li>IFC cutoff radius</li>
  <li>Brillouin zone integration grid (q-mesh)</li>
</ul>

<p>Nevertheless, PBTE is considered one of the most reliable methods for predicting lattice thermal conductivity. It not only yields <strong>total κ</strong>, but also <strong>mode-resolved contributions</strong>, enabling studies of interfacial thermal conductance and nanoscale transport.</p>

<h3 id="5-software-and-interfaces">(5) Software and Interfaces</h3>

<p>Several open-source packages support this workflow:</p>

<ul>
  <li><strong>ShengBTE</strong></li>
  <li><strong>phono3py</strong></li>
</ul>

<p>These integrate well with major first-principles codes like:</p>

<ul>
  <li><strong>VASP</strong></li>
  <li><strong>Quantum ESPRESSO</strong></li>
  <li><strong>ABINIT</strong></li>
</ul>

<p>They enable an end-to-end automated workflow from structure optimization to IFC extraction and thermal conductivity prediction.</p>]]></content><author><name></name></author><category term="Heat-conduction" /><category term="Calculation" /><summary type="html"><![CDATA[In microscale and nanoscale heat conduction, size effects mainly involve two key length scales: phonon wavelength and mean free path (MFP).]]></summary></entry><entry><title type="html">Topological Quantities and Properties of Phonons</title><link href="https://lyushisyan.github.io/blog/2024/topology/" rel="alternate" type="text/html" title="Topological Quantities and Properties of Phonons" /><published>2024-12-02T02:36:10+03:00</published><updated>2024-12-02T02:36:10+03:00</updated><id>https://lyushisyan.github.io/blog/2024/topology</id><content type="html" xml:base="https://lyushisyan.github.io/blog/2024/topology/"><![CDATA[<h2 id="topological-geometry">Topological Geometry</h2>

<p>Topology studies geometric properties that remain invariant under continuous transformations, reflecting global characteristics.<br />
For example, the <strong>Gaussian curvature</strong> $K$ of a surface describes local geometric properties and is related to global topological characteristics through the <strong>Gauss-Bonnet theorem</strong>:</p>

\[\int_S K \, d^2r = 4\pi (1-\text{genus}),\]

<p>where $\text{genus}$ represents the number of holes in a geometric object. For example, the genus of a sphere is $0$, while the genus of a torus (like a donut) is $1$.</p>

<div class="text-center">
  



<figure>
  <picture>
    <!-- Auto scaling with imagemagick -->
    <!--
      See https://www.debugbear.com/blog/responsive-images#w-descriptors-and-the-sizes-attribute and
      https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images for info on defining 'sizes' for responsive images
    -->
    
      <source class="responsive-img-srcset" srcset="/assets/img/blog/topology_huan-480.webp 480w,/assets/img/blog/topology_huan-800.webp 800w,/assets/img/blog/topology_huan-1400.webp 1400w," type="image/webp" sizes="95vw" />
    
    <img src="/assets/img/blog/topology_huan.gif" class="w-75" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();" />
  </picture>

  
    <figcaption class="caption">Figure 1: A continuous deformation (a type of homeomorphism) of a mug into a doughnut (torus)</figcaption>
  
</figure>

</div>

<h2 id="topological-physics">Topological Physics</h2>

<p>Topological physics primarily investigates the topological properties in momentum space. In periodic lattices, electronic states can be described by the time-independent Schrödinger equation:</p>

\[H|\varphi\rangle = E|\varphi\rangle,\]

<p>where $H$ is the Hamiltonian of the system, $E$ is the energy eigenvalue of the electron, and $\vert\varphi\rangle$ is the corresponding eigenstate. By solving this equation, one can obtain the band structure, i.e., the relationship between energy and momentum of electrons.</p>

<p>Traditional band theory focuses on the energy eigenvalues of electrons, while the significant contribution of topological physics lies in uncovering the hidden topological information within wavefunctions, i.e., the topology of electronic wavefunctions. For example, in the <strong>quantum Hall effect</strong>, the time-reversal symmetry of the system is broken, and the Chern number \(C \neq 0\). Based on different symmetries, researchers have developed many topological material systems, such as the valley Hall effect, topological crystalline insulators, and gapless topological semimetals, including Dirac states, Weyl states, nodal lines, and triple degeneracy points.</p>

<h2 id="topological-phonons">Topological Phonons</h2>

<p>Phonons, lacking charge and spin properties, entered topological research relatively late. Traditionally, phonon studies primarily focused on their particle-like properties (dispersion and scattering) and wave-like properties (coherence effects). Inspired by the analogy between phonons and electrons, researchers have recently observed novel transport phenomena in phononic systems, such as the <strong>phonon thermal Hall effect</strong>.</p>

<p>In phononic systems, breaking time-reversal symmetry is challenging. For crystals with time-reversal symmetry, atomic vibrations can be described by the equations of motion based on Newton’s laws. Under the harmonic approximation, the phonon characteristic equation can be written as:</p>

\[\boldsymbol{D}(\boldsymbol{k}) \boldsymbol{u}(\boldsymbol{k}) = \omega^2(\boldsymbol{k}) \boldsymbol{u}(\boldsymbol{k}),\]

<p>where $\boldsymbol{u}(\boldsymbol{k})$ is the phonon eigenstate, and $\omega(\boldsymbol{k})$ is the phonon frequency. Traditional studies only focus on eigenvalues, yielding phonon dispersion relations and density of states, while topological phonon research further explores the hidden topological information within eigenstates.</p>

<h3 id="topological-quantities-in-phononic-systems">Topological Quantities in Phononic Systems</h3>

<p>Using the wavefunctions of phonon eigenstates, topological quantities can be defined:</p>

<ul>
  <li>
    <p><strong>Berry Connection</strong>:</p>

\[A_{s,\boldsymbol{k}} = \text{i} \langle u_{s\boldsymbol{k}} | \nabla_{\boldsymbol{k}} | u_{s\boldsymbol{k}} \rangle,\]

    <p>describing the geometric properties of wavefunctions in momentum space.</p>
  </li>
  <li>
    <p><strong>Berry Curvature</strong>:</p>

\[\Omega_{s,\boldsymbol{k}} = \nabla_{\boldsymbol{k}} \times A_{s,\boldsymbol{k}},\]

    <p>the curl of the Berry connection, characterizing the local topological structure of wavefunctions in momentum space.</p>
  </li>
  <li>
    <p><strong>Berry Phase</strong>:</p>

\[\gamma_s = \int_L A \cdot d\boldsymbol{k},\]

    <p>the integral of the Berry connection along a specific path or loop.</p>
  </li>
  <li>
    <p><strong>Chern Number</strong>:<br />
In three-dimensional systems, the Chern number is defined as the integral over a closed surface in momentum space:</p>

\[C = \frac{1}{2\pi} \oint \Omega_{s,\boldsymbol{k}} d^2\boldsymbol{k}.\]
  </li>
</ul>

<p>Since phonons do not have spin $1/2$ properties, the theory of quantum spin Hall states cannot be directly applied. Quantum spin Hall states in electronic systems can be seen as two quantum Hall states with opposite Chern numbers, resulting in a total Chern number of $0$ under time-reversal symmetry. In phononic systems, lattice symmetry can be used to achieve double or multiple degeneracies, constructing pseudo-spin-like properties and providing new approaches to topological phonon research.</p>

<p>In classical phonon transport research, lattice symmetry is used to analyze phonon scattering channels and simplify force constant calculations. From the perspective of topological phonons, lattice symmetry is primarily used to determine phonon degeneracy and classify phonon branches.</p>

<p>At the boundaries or interfaces of materials, topological phonons can form special boundary states. These boundary states originate from inherent topological invariants of materials (such as Chern numbers or Berry curvature) and can propagate along scattering-free channels. This stability is known as the <strong>topological protection mechanism</strong>.</p>

<p>The dispersion relations of topological phonons also exhibit unique characteristics. In certain frequency ranges, phonon propagation is more efficient, while in other ranges, phonons may be suppressed.</p>]]></content><author><name></name></author><category term="Physics" /><summary type="html"><![CDATA[Topological Geometry]]></summary></entry><entry><title type="html">VASP Structure Optimization</title><link href="https://lyushisyan.github.io/blog/2024/vasp-relax/" rel="alternate" type="text/html" title="VASP Structure Optimization" /><published>2024-12-02T02:36:10+03:00</published><updated>2024-12-02T02:36:10+03:00</updated><id>https://lyushisyan.github.io/blog/2024/vasp-relax</id><content type="html" xml:base="https://lyushisyan.github.io/blog/2024/vasp-relax/"><![CDATA[<h2 id="1-input-files">1. Input Files</h2>
<p>The input files for VASP are the four basic files: <code class="language-plaintext highlighter-rouge">INCAR</code>, <code class="language-plaintext highlighter-rouge">POSCAR</code>, <code class="language-plaintext highlighter-rouge">POTCAR</code>, <code class="language-plaintext highlighter-rouge">KPOINTS</code>.</p>

<h3 id="11-incar-parameter-settings">1.1 <code class="language-plaintext highlighter-rouge">INCAR</code> Parameter Settings</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>System <span class="o">=</span> Si-film    <span class="c"># System name, can be freely defined to identify the current calculation system.</span>

<span class="c"># Job Control</span>
ISTART <span class="o">=</span> 0          <span class="c"># Initial state setup:</span>
                    <span class="c"># 0 Start calculation from scratch.</span>
                    <span class="c"># 1 Read initial wavefunctions from WAVECAR file.</span>
                    <span class="c"># 2 Read wavefunctions and charge density from WAVECAR and CHGCAR files.</span>
ISPIN <span class="o">=</span> 1           <span class="c"># Spin polarization options:</span>
                    <span class="c"># 1 Non-spin-polarized (for non-magnetic materials).</span>
                    <span class="c"># 2 Spin-polarized (for magnetic materials).</span>
ICHARGE <span class="o">=</span> 2         <span class="c"># Initial charge density selection:</span>
                    <span class="c"># 2 Start from static charge density provided by POTCAR.</span>
                    <span class="c"># 1 Generate charge density from scratch.</span>
LWAVE <span class="o">=</span> .FALSE.     <span class="c"># Output WAVECAR file:</span>
                    <span class="c"># .TRUE. Output (store wavefunction data).</span>
                    <span class="c"># .FALSE. Do not output (save disk space).</span>
LCHARG <span class="o">=</span> .FALSE.    <span class="c"># Output CHGCAR file:</span>
                    <span class="c"># .TRUE. Output (store static charge density).</span>
                    <span class="c"># .FALSE. Do not output (save disk space).</span>
ISYM <span class="o">=</span> 0            <span class="c"># Symmetry settings:</span>
                    <span class="c"># 0 Disable symmetry (for systems with defects or asymmetric structures).</span>
                    <span class="c"># 1 or 2 Preserve symmetry operations.</span>

<span class="c"># Electronic Relaxation</span>
ENCUT <span class="o">=</span> 500         <span class="c"># Plane-wave cutoff energy (eV), determines calculation precision and efficiency.</span>
ISMEAR <span class="o">=</span> 0          <span class="c"># Smearing method:</span>
                    <span class="c"># -5 (tetrahedron method for metals), 0 (Gaussian smearing for semiconductors), 1 or 2 (Fermi smearing).</span>
SIGMA <span class="o">=</span> 0.05        <span class="c"># Smearing width (eV), recommended values: 0.01 ~ 0.1.</span>
EDIFF <span class="o">=</span> 1E-08       <span class="c"># SCF convergence criterion: stops if energy change between iterations is less than 1E-08 eV.</span>
NELMIN <span class="o">=</span> 6          <span class="c"># Minimum number of electronic iterations to ensure basic convergence.</span>
NELM <span class="o">=</span> 300          <span class="c"># Maximum number of electronic iterations to avoid iteration loops.</span>
GGA <span class="o">=</span> PE            <span class="c"># Functional choice, using PBE (Perdew-Burke-Ernzerhof) exchange-correlation functional.</span>
LREAL <span class="o">=</span> .FALSE.     <span class="c"># Reciprocal space calculations, increases precision but adds computational cost.</span>
ADDGRID <span class="o">=</span> .TRUE.    <span class="c"># Enable additional FFT grid for improved numerical accuracy.</span>
ALGO <span class="o">=</span> N            <span class="c"># Electronic relaxation algorithm:</span>
                    <span class="c"># Normal (standard mode), Fast, or VeryFast (accelerated modes).</span>
PREC <span class="o">=</span> Accurate     <span class="c"># Precision settings:</span>
                    <span class="c"># Accurate (high precision), Normal, or Low (for initial tests).</span>

<span class="c"># Ionic Relaxation</span>
ISIF <span class="o">=</span> 2            <span class="c"># Lattice optimization options:</span>
                    <span class="c"># 2 Optimize atomic positions only, keep lattice parameters fixed.</span>
                    <span class="c"># 3 Optimize both atomic positions and lattice shape.</span>
EDIFFG <span class="o">=</span> <span class="nt">-0</span>.01      <span class="c"># Ionic convergence criterion:</span>
                    <span class="c"># Negative values based on force (eV/\u00c5).</span>
                    <span class="c"># Positive values based on energy.</span>
IBRION <span class="o">=</span> 2          <span class="c"># Ionic relaxation algorithm:</span>
                    <span class="c"># 2 Conjugate gradient algorithm (suitable for most optimization tasks).</span>
POTIM <span class="o">=</span> 0.5         <span class="c"># Time step, controls optimization speed.</span>
NSW <span class="o">=</span> 200           <span class="c"># Maximum number of ionic steps.</span>

<span class="c"># Parallel Control</span>
NPAR <span class="o">=</span> 4            <span class="c"># FFT grid parallelization dimension (recommended: sqrt(total cores)).</span>
KPAR <span class="o">=</span> 2            <span class="c"># Number of parallel k-points (total cores should be divisible by NPAR \u00d7 KPAR \u00d7 NCORE).</span>
NCORE <span class="o">=</span> 12          <span class="c"># Number of cores per task.</span>
</code></pre></div></div>

<p>For structural optimization, key parameters in <code class="language-plaintext highlighter-rouge">INCAR</code> include <code class="language-plaintext highlighter-rouge">IBRION</code>, <code class="language-plaintext highlighter-rouge">ISIF</code>, <code class="language-plaintext highlighter-rouge">NSW</code>, <code class="language-plaintext highlighter-rouge">EDIFF</code>, and <code class="language-plaintext highlighter-rouge">EDIFFG</code>.</p>

<h4 id="111-common-ibrion-settings-and-applications">1.1.1 Common <code class="language-plaintext highlighter-rouge">IBRION</code> Settings and Applications</h4>

<h5 id="1-single-point-energy-calculation">(1) Single-Point Energy Calculation</h5>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">IBRION = -1</code></strong><br />
<strong>Usage</strong>: Used for single-point energy calculations such as fixed lattice, electronic structure, or DOS analysis.<br />
<strong>Note</strong>: Avoid setting <code class="language-plaintext highlighter-rouge">NSW &gt; 0</code> to prevent wasting resources.</li>
</ul>

<h5 id="2-structure-optimization">(2) Structure Optimization</h5>
<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">IBRION = 1</code></strong> (RMM-DIIS)<br />
<strong>Usage</strong>: Suitable for smooth potential energy surfaces in simple systems.<br />
<strong>Limitation</strong>: May encounter convergence issues for complex or unstable surfaces.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">IBRION = 2</code></strong> (Conjugate Gradient)<br />
<strong>Usage</strong>: Most commonly used method, suitable for most systems.<br />
<strong>Advantage</strong>: Performs well for steep and complex surfaces.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">IBRION = 3</code></strong> (Damped Molecular Dynamics)<br />
<strong>Usage</strong>: Stabilizes optimization paths that oscillate or diverge.</p>
  </li>
</ul>

<h5 id="3-molecular-dynamics">(3) Molecular Dynamics</h5>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">IBRION = 0</code></strong><br />
<strong>Usage</strong>: For studying dynamic behavior of systems at different temperatures, such as diffusion or vibrational modes.</li>
</ul>

<h5 id="4-phonon-calculations">(4) Phonon Calculations</h5>

<p>a. <strong>Finite Difference Method</strong> <strong><code class="language-plaintext highlighter-rouge">IBRION = 5, 6</code></strong><br />
Calculates phonon modes using finite difference:</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">5</code></strong>: Without symmetry, suitable for defective or low-symmetry structures.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">6</code></strong>: Exploits symmetry for efficient calculations in high-symmetry systems.</li>
</ul>

<p>b. <strong>Perturbation Theory (DFPT)</strong> <strong><code class="language-plaintext highlighter-rouge">IBRION = 7, 8</code></strong><br />
Calculates phonon modes using density functional perturbation theory (DFPT):</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">7</code></strong>: Without symmetry optimization, suitable for low-symmetry structures.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">8</code></strong>: Utilizes symmetry for faster computation.</li>
</ul>

<h4 id="112-common-isif-settings-and-applications">1.1.2 Common <code class="language-plaintext highlighter-rouge">ISIF</code> Settings and Applications</h4>

<ul>
  <li>
    <p>Default value (if not set): <code class="language-plaintext highlighter-rouge">ISIF = 2</code> (Optimize atomic positions only, keep lattice shape and volume fixed).</p>
  </li>
  <li>Special Cases:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">IBRION = 0</code> (molecular dynamics) or <code class="language-plaintext highlighter-rouge">LHFCALC = .TRUE.</code> (hybrid functional): <code class="language-plaintext highlighter-rouge">ISIF = 0</code>.</li>
    </ul>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">ISIF = 2</code> (Most Common)</strong><br />
Optimizes atomic positions only, suitable for 2D materials, fixed lattice constants, or surface/interface systems.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">ISIF = 3</code> (Bulk Optimization)</strong><br />
Optimizes atomic positions, lattice shape, and volume, suitable for bulk material relaxations.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">ISIF = 4</code> (Fixed Volume Optimization)</strong><br />
Optimizes atomic positions and lattice shape while keeping the volume fixed, useful for pressure tests.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">ISIF = 6</code> (Lattice-Only Optimization)</strong><br />
Optimizes lattice shape and volume without relaxing atomic positions, useful for testing lattice parameters.</p>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">ISIF = 0</code> (Position Optimization, No Stress Calculation)</strong><br />
Optimizes atomic positions without calculating stress, for fixed cell optimizations.</li>
</ul>

<h4 id="113-recommended-settings-for-nsw-ediff-and-ediffg">1.1.3 Recommended Settings for <code class="language-plaintext highlighter-rouge">NSW</code>, <code class="language-plaintext highlighter-rouge">EDIFF</code>, and <code class="language-plaintext highlighter-rouge">EDIFFG</code></h4>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Function</th>
      <th>Initial Optimization</th>
      <th>High-Precision Optimization</th>
      <th>Single Point</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">NSW</code></td>
      <td>Max ionic steps</td>
      <td>100-200</td>
      <td>200-500</td>
      <td>0</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">EDIFF</code></td>
      <td>SCF convergence (eV)</td>
      <td>1e-05</td>
      <td>1e-08</td>
      <td>1e-06</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">EDIFFG</code></td>
      <td>Ionic convergence (eV/\u00c5)</td>
      <td>-0.1</td>
      <td>-0.01</td>
      <td>Not required</td>
    </tr>
  </tbody>
</table>

<h3 id="12-example-poscar">1.2 Example <code class="language-plaintext highlighter-rouge">POSCAR</code></h3>

<p>Below is an example <code class="language-plaintext highlighter-rouge">POSCAR</code> file describing the structure of bulk silicon:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Si-bulk   <span class="c"># System name, customizable</span>
1.0       <span class="c"># Global scaling factor (can be used to scale the lattice)</span>
   5.430    0.000    0.000  <span class="c"># Lattice vector a</span>
   0.000    5.430    0.000  <span class="c"># Lattice vector b</span>
   0.000    0.000    5.430  <span class="c"># Lattice vector c</span>
Si           <span class="c"># Atom types</span>
2            <span class="c"># Number of atoms for each type</span>
Direct       <span class="c"># Coordinate type (Direct: fractional; Cartesian: cartesian)</span>
  0.000  0.000  0.000  <span class="c"># Coordinates for atom 1</span>
  0.250  0.250  0.250  <span class="c"># Coordinates for atom 2</span>
</code></pre></div></div>

<p>Example POSCAR File for Silicon Thin Film (Si-film):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Si Thin Film                            
   1.00000000000000     
     5.4299999999999997    0.0000000000000000    0.0000000000000000
     0.0000000000000000    5.4299999999999997    0.0000000000000000
     0.0000000000000000    0.0000000000000000   20.8599999999999994
   Si
    16
Selective dynamics  <span class="c"># Enable Selective Dynamics</span>
Direct
0.000000 0.000000 0.200000 F F F  <span class="c"># Fixed in all three directions</span>
0.500000 0.500000 0.200000 T T F  <span class="c"># Fixed in z-direction, free in x and y</span>
0.500000 0.000000 0.330153 T T T  <span class="c"># Free in all directions</span>
0.000000 0.500000 0.330153 T T T
0.250000 0.250000 0.265077 T T T
0.750000 0.750000 0.265077 T T T
0.750000 0.250000 0.395230 T T T
0.250000 0.750000 0.395230 T T T
0.000000 0.000000 0.460307 T T T
0.500000 0.500000 0.460307 T T T
0.500000 0.000000 0.590460 T T T
0.000000 0.500000 0.590460 T T T
0.250000 0.250000 0.525384 T T T
0.750000 0.750000 0.525384 T T T
0.750000 0.250000 0.655537 T T T
0.250000 0.750000 0.655537 T T T
</code></pre></div></div>

<h3 id="13-kpoints-file">1.3 KPOINTS File</h3>

<h4 id="1-monkhorst-pack-grid">(1) Monkhorst-Pack Grid</h4>
<p>Monkhorst-Pack grids provide a uniform k-point distribution for periodic crystal calculations.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Automatic k-point generation   <span class="c"># Automatic k-point generation method (comment)</span>
0                              <span class="c"># Ignore total k-point count, use automatic generation</span>
Monkhorst-Pack                 <span class="c"># Choose Monkhorst-Pack grid</span>
4 4 4                          <span class="c"># Grid density in x, y, z directions</span>
0 0 0                          <span class="c"># No grid shift</span>
</code></pre></div></div>

<p><strong>Use Case:</strong> Periodic crystals, optimization, DOS calculations, and electronic structure analysis.</p>

<h4 id="2-gamma-grid">(2) Gamma Grid</h4>
<p>Gamma grids center the k-point grid at the Gamma point, suitable for small or asymmetric lattices.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Automatic k-point generation   <span class="c"># Automatic k-point generation method (comment)</span>
0                              <span class="c"># Ignore total k-point count, use automatic generation</span>
Gamma                          <span class="c"># Choose Gamma-centered grid</span>
4 4 4                          <span class="c"># Grid density in x, y, z directions</span>
0 0 0                          <span class="c"># No grid shift</span>
</code></pre></div></div>

<p><strong>Use Case:</strong> Small systems, asymmetric lattices, or fast calculation optimization tasks.</p>

<h3 id="14-potcar-file-usage">1.4 POTCAR File Usage</h3>

<p>POTCAR contains pseudopotential information required to describe atomic properties in the system.</p>

<h4 id="vasp-provides-multiple-types-of-pseudopotentials">VASP Provides Multiple Types of Pseudopotentials:</h4>
<ul>
  <li><strong>POT_GGA_PAW:</strong> PAW pseudopotentials with GGA functional.</li>
  <li><strong>POT_LDA_PAW:</strong> PAW pseudopotentials with LDA functional.</li>
</ul>

<h4 id="generating-the-potcar-file">Generating the POTCAR File:</h4>
<p>For a system with atoms like Si and H, concatenate the pseudopotential files:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /POT_GGA_PAW/POTCAR_Si /POT_GGA_PAW/POTCAR_H <span class="o">&gt;</span> POTCAR
</code></pre></div></div>

<ul>
  <li>Ensure the functional type in POTCAR matches the INCAR settings.</li>
  <li>Maintain the atom order in POTCAR consistent with the element order in POSCAR.</li>
</ul>

<h2 id="2-output-files">2. Output Files</h2>

<h3 id="21-contcar-file">2.1 CONTCAR File</h3>

<p><strong>Content:</strong> Optimized crystal structure, including updated atomic coordinates and lattice parameters.
<strong>Format:</strong> Same as POSCAR, can directly serve as input for further calculations.
<strong>Use Case:</strong></p>
<ul>
  <li>Review the final optimized crystal structure.</li>
  <li>Use for further calculations (e.g., band structure, DOS).</li>
</ul>

<h3 id="22-oszicar-file">2.2 OSZICAR File</h3>

<p><strong>Content:</strong></p>
<ul>
  <li>Brief record of SCF (Self-Consistent Field) iteration energy changes.</li>
  <li>Energy (E0, dE) for each SCF step.</li>
  <li>Convergence information for SCF.</li>
  <li>Total energy changes per ion step during optimization.</li>
</ul>

<p><strong>Use Case:</strong></p>
<ul>
  <li>Quickly check SCF calculation or optimization convergence.</li>
  <li>Decide if adjustments to EDIFF or optimization steps are necessary.</li>
</ul>

<h3 id="23-outcar-file">2.3 OUTCAR File</h3>

<p><strong>Content:</strong></p>
<ul>
  <li>Most detailed output file with complete calculation history.</li>
  <li>Includes parameters like electronic relaxation, iteration info, convergence criteria, etc.</li>
  <li>Energy, force, stress, atomic coordinates for each optimization step.</li>
  <li>Charge density info (if applicable).</li>
</ul>

<p><strong>Use Case:</strong></p>
<ul>
  <li>Analyze convergence details and energy/force variations during optimization.</li>
</ul>

<h3 id="24-xdatcar-file">2.4 XDATCAR File</h3>

<p><strong>Content:</strong></p>
<ul>
  <li>Atomic coordinates for each ionic step during optimization or molecular dynamics (MD).</li>
</ul>

<p><strong>Use Case:</strong></p>
<ul>
  <li>Analyze atomic movement paths during optimization.</li>
  <li>Perform trajectory analysis for structural changes.</li>
</ul>

<h3 id="25-vasprunxml-file">2.5 vasprun.xml File</h3>

<p><strong>Content:</strong> XML-formatted record of all calculation data, suitable for parsing and post-processing.</p>
<ul>
  <li>Includes electronic iteration, ionic optimization parameters, and results.</li>
  <li>Data for energy, force, stress, atomic coordinates, etc.</li>
</ul>

<p><strong>Use Case:</strong></p>
<ul>
  <li>Extract key information using tools like pymatgen or ASE.</li>
</ul>

<h2 id="3-optimization-process-and-convergence-criteria">3. Optimization Process and Convergence Criteria</h2>

<h3 id="31-optimization-process">3.1 Optimization Process</h3>

<ol>
  <li><strong>Initialization of the Structure:</strong>
    <ul>
      <li>The initial structure is provided through the <code class="language-plaintext highlighter-rouge">POSCAR</code> file.</li>
      <li>The optimization conditions are configured using the <code class="language-plaintext highlighter-rouge">POTCAR</code>, <code class="language-plaintext highlighter-rouge">KPOINTS</code>, and <code class="language-plaintext highlighter-rouge">INCAR</code> files.</li>
    </ul>
  </li>
  <li><strong>Stepwise Optimization:</strong>
    <ul>
      <li>After each ionic optimization step, the total energy, atomic forces, and lattice stress of the system are recalculated.</li>
      <li>The optimization continues until convergence criteria (e.g., <code class="language-plaintext highlighter-rouge">EDIFFG</code>) are satisfied or the maximum number of steps (<code class="language-plaintext highlighter-rouge">NSW</code>) is reached.</li>
    </ul>
  </li>
  <li><strong>Structure Updates:</strong>
    <ul>
      <li>Intermediate results of each optimization step are stored in the <code class="language-plaintext highlighter-rouge">XDATCAR</code> file.</li>
      <li>The final structure after optimization is saved in the <code class="language-plaintext highlighter-rouge">CONTCAR</code> file.</li>
    </ul>
  </li>
</ol>

<h3 id="32-convergence-criteria">3.2 Convergence Criteria</h3>

<p>The convergence of the optimization process can be determined using the following methods:</p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">OUTCAR</code> File:</strong>
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>Check whether the force on each atom is less than</td>
              <td><code class="language-plaintext highlighter-rouge">EDIFFG</code></td>
              <td>.</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>Verify whether the total energy change is less than <code class="language-plaintext highlighter-rouge">EDIFF</code>.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">OSZICAR</code> File:</strong>
    <ul>
      <li>Review the energy changes (<code class="language-plaintext highlighter-rouge">E0</code> and <code class="language-plaintext highlighter-rouge">dE</code>) during the SCF iterations.</li>
      <li>Determine whether the SCF process has stabilized and converged.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">CONTCAR</code> File:</strong>
    <ul>
      <li>Extract the final optimized atomic positions and lattice parameters.</li>
      <li>If the optimization has not converged, the <code class="language-plaintext highlighter-rouge">CONTCAR</code> file contains the structure from the last step.</li>
    </ul>
  </li>
  <li><strong>Using Tools:</strong>
    <ul>
      <li>Use tools like <code class="language-plaintext highlighter-rouge">pymatgen</code> or <code class="language-plaintext highlighter-rouge">ASE</code> to parse the <code class="language-plaintext highlighter-rouge">vasprun.xml</code> file and evaluate convergence.</li>
    </ul>
  </li>
</ol>

<h3 id="33-common-issues-and-solutions">3.3 Common Issues and Solutions</h3>

<h4 id="331-scf-not-converging"><strong>3.3.1 SCF Not Converging</strong></h4>

<p><strong>Issue:</strong> SCF iterations show energy oscillations or divergence.</p>

<p><strong>Possible Causes:</strong></p>
<ul>
  <li>The initial electronic density is poorly set.</li>
  <li>Insufficient cutoff energy (<code class="language-plaintext highlighter-rouge">ENCUT</code>).</li>
</ul>

<p><strong>Solutions:</strong></p>
<ul>
  <li>Increase the maximum number of SCF iterations by setting <code class="language-plaintext highlighter-rouge">NELM=200</code>.</li>
  <li>Raise the cutoff energy: increase <code class="language-plaintext highlighter-rouge">ENCUT</code> to 520 eV or higher.</li>
</ul>

<h4 id="332-optimization-not-converging"><strong>3.3.2 Optimization Not Converging</strong></h4>

<p><strong>Issue:</strong> Optimization reaches the maximum steps (<code class="language-plaintext highlighter-rouge">NSW</code>) but does not meet convergence criteria for force or energy.</p>

<p><strong>Possible Causes:</strong></p>
<ul>
  <li>The initial structure is far from the energy minimum.</li>
  <li>Convergence criteria (<code class="language-plaintext highlighter-rouge">EDIFFG</code>) are too strict.</li>
  <li>The optimization step size (<code class="language-plaintext highlighter-rouge">POTIM</code>) is too large.</li>
</ul>

<p><strong>Solutions:</strong></p>
<ul>
  <li>Provide a reasonable initial structure or pre-optimize using external tools.</li>
  <li>Relax the convergence criteria: adjust <code class="language-plaintext highlighter-rouge">EDIFFG</code> from <code class="language-plaintext highlighter-rouge">-0.01</code> to <code class="language-plaintext highlighter-rouge">-0.02</code>.</li>
  <li>Reduce the optimization step size: adjust <code class="language-plaintext highlighter-rouge">POTIM</code> from <code class="language-plaintext highlighter-rouge">0.5</code> to <code class="language-plaintext highlighter-rouge">0.2</code>.</li>
</ul>

<h4 id="333-oscillations-during-optimization"><strong>3.3.3 Oscillations During Optimization</strong></h4>

<p><strong>Issue:</strong> Energy and forces oscillate repeatedly during optimization, preventing stable convergence.</p>

<p><strong>Possible Causes:</strong></p>
<ul>
  <li>The optimization step size (<code class="language-plaintext highlighter-rouge">POTIM</code>) is too large.</li>
  <li>The optimization algorithm is unsuitable for the system.</li>
</ul>

<p><strong>Solutions:</strong></p>
<ul>
  <li>Decrease the optimization step size: set <code class="language-plaintext highlighter-rouge">POTIM</code> to <code class="language-plaintext highlighter-rouge">0.2</code> or smaller.</li>
  <li>Change the optimization algorithm:
    <ul>
      <li>Use the conjugate gradient method by setting <code class="language-plaintext highlighter-rouge">IBRION=2</code>.</li>
      <li>Use damped molecular dynamics by setting <code class="language-plaintext highlighter-rouge">IBRION=3</code>.</li>
    </ul>
  </li>
</ul>

<h4 id="334-divergence-during-optimization"><strong>3.3.4 Divergence During Optimization</strong></h4>

<p><strong>Issue:</strong> Severe deformation of the structure occurs during optimization, leading to significant energy increases.</p>

<p><strong>Possible Causes:</strong></p>
<ul>
  <li>Atomic distances are too short due to an unreasonable initial structure.</li>
  <li>Inadequate vacuum spacing (for low-dimensional systems such as thin films or nanostructures).</li>
  <li>Incorrect pseudopotential files.</li>
</ul>

<p><strong>Solutions:</strong></p>
<ul>
  <li>Ensure reasonable initial atomic distances to avoid overly close atoms.</li>
  <li>Increase the vacuum spacing: for low-dimensional systems, set the vacuum layer thickness to at least 15 Å.</li>
  <li>Verify the <code class="language-plaintext highlighter-rouge">POTCAR</code> file to ensure the pseudopotential matches the atomic species.</li>
</ul>]]></content><author><name></name></author><category term="Calculation" /><summary type="html"><![CDATA[1. Input Files The input files for VASP are the four basic files: INCAR, POSCAR, POTCAR, KPOINTS.]]></summary></entry><entry><title type="html">Theoretical framework for phonon Monte Carlo simulations</title><link href="https://lyushisyan.github.io/blog/2024/MC-phononBTE/" rel="alternate" type="text/html" title="Theoretical framework for phonon Monte Carlo simulations" /><published>2024-11-16T02:36:10+03:00</published><updated>2024-11-16T02:36:10+03:00</updated><id>https://lyushisyan.github.io/blog/2024/MC-phononBTE</id><content type="html" xml:base="https://lyushisyan.github.io/blog/2024/MC-phononBTE/"><![CDATA[<h2 id="1-boltzmann-transport-equation">1. Boltzmann Transport Equation</h2>

<h3 id="11-particle-based-boltzmann-transport-equation">1.1 Particle-Based Boltzmann Transport Equation:</h3>

\[\frac{\partial f}{\partial t} + \boldsymbol v_g(\omega,p)\nabla f = - \frac{f-f^{\text{loc}}}{\tau(\omega,p,T)}\]

<p>where $f=f(t,\boldsymbol x,\boldsymbol k,p)$ is the phonon distribution function in phase space, $\omega=\omega(\boldsymbol k,p)$ is the phonon angular frequency, $p$ is phonon polarization, and $T$ is temperature. Moreover, $f^\text{loc}$ is the BE equilibrium distribution parameterized by a local pseudo-temperature.</p>

<p>Using phonon bundles to represent simulated particles:</p>

\[f(t,\boldsymbol x,\boldsymbol k,p) \approx 8\pi^3N_\text{eff}\sum_i \delta^3(\boldsymbol x - \boldsymbol x_i) \delta^3(\boldsymbol k - \boldsymbol k_i) \delta_{p,p_i}\]

<p>where $N_\text{eff}$ is the effective number of phonons in each phonon bundle.</p>

<h3 id="12-energy-based-boltzmann-transport-equation-energy-based-bte">1.2 Energy-Based Boltzmann Transport Equation (Energy-Based BTE):</h3>

\[\frac{\partial e}{\partial t} + \boldsymbol v_g\nabla e = - \frac{e-e^{\text{loc}}}{\tau}\]

<p>Here, simulated particles represent energy $e=\hbar\omega f$, and $e^\text{loc}=\hbar\omega f^\text{loc}$.</p>

\[e \approx 8\pi^3\varepsilon_\text{eff}\sum_i \delta^3(\boldsymbol x - \boldsymbol x_i) \delta^3(\boldsymbol k - \boldsymbol k_i) \delta_{p,p_i}\]

<p>where $\varepsilon_\text{eff}$ is defined as the effective energy carried by each simulated particle, $\varepsilon_\text{eff}=N_\text{eff}\hbar\omega$. The effective number of phonons represented by the energy particle $\varepsilon_\text{eff}$ is variable.</p>

<h3 id="13-deviational-energy-based-boltzmann-transport-equation-deviational-energy-based-bte">1.3 Deviational Energy-Based Boltzmann Transport Equation (Deviational Energy-Based BTE):</h3>

\[\frac{\partial e^d}{\partial t} + \boldsymbol v_g\nabla e^d = \frac{(e^{\text{loc}}-e^{\text{eq}}_{T_\text{eq}})-e^d}{\tau}\]

<p>where,</p>

\[e^{\text{eq}}_{T_\text{eq}}(\omega) = \frac{\hbar\omega}{\exp\left(\frac{\hbar\omega}{k_BT_\text{eq}}\right)-1}\]

<p>Here, simulated particles represent deviational energy: $e^d = e - e^{\text{eq}}<em>{T</em>\text{eq}}$.</p>

\[e^d \approx 8\pi^3\varepsilon_\text{eff}^d\sum_i s(i) \delta^3(\boldsymbol x - \boldsymbol x_i) \delta^3(\boldsymbol k - \boldsymbol k_i) \delta_{p,p_i}\]

<p>$s(i)=+1$ represents a share of deviational energy increase relative to the reference state (the “excess” phonon group in higher-temperature regions).</p>

<p>$s(i)=-1$ represents a share of deviational energy decrease relative to the reference state (the “deficient” phonon group in lower-temperature regions).</p>

<div class="row">
    <div class="col-md-6 text-center">
        



<figure>
  <picture>
    <!-- Auto scaling with imagemagick -->
    <!--
      See https://www.debugbear.com/blog/responsive-images#w-descriptors-and-the-sizes-attribute and
      https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images for info on defining 'sizes' for responsive images
    -->
    
      <source class="responsive-img-srcset" srcset="/assets/img/blog/detaE-480.webp 480w,/assets/img/blog/detaE-800.webp 800w,/assets/img/blog/detaE-1400.webp 1400w," type="image/webp" sizes="95vw" />
    
    <img src="/assets/img/blog/detaE.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();" />
  </picture>

  
</figure>

    </div>
</div>

<p>The deviational energy method focuses calculations on the non-equilibrium energy deviations by introducing a reference equilibrium temperature $T_\text{eq}$, rather than the full phonon distribution function. This reduces the simulation of large numbers of equilibrium phonons, significantly improving simulation efficiency, especially in cases of small temperature differences or near-equilibrium states.</p>

<p>In the deviational energy method, the number and sign (positive or negative) of simulated particles directly correspond to changes in deviational energy, reducing energy errors during particle addition or removal. Moreover, the computation inherently follows the principle of energy conservation.</p>

<h2 id="2-monte-carlo-simulation-algorithm">2. Monte Carlo Simulation Algorithm</h2>

<h3 id="21-particle-based-simulation">2.1 Particle-Based Simulation</h3>

<h3 id="initialization"><strong>Initialization:</strong></h3>

<p>At the initial temperature $T$, use BE statistics to calculate the number of phonons in volume $V$:</p>

\[N=V\int_{\omega=0}^{\omega_\text{max}}\sum_p D(\omega,p) f_T^\text{eq}(\omega) d\omega\]

<p>The number of simulated particles (each representing a phonon bundle) is given by $N/N_\text{eff}$.</p>

<p>The value of $N_\text{eff}$ is determined by balancing computational cost and the number of particles needed to obtain statistically meaningful results.</p>

<h3 id="time-evolution"><strong>Time Evolution:</strong></h3>

<p>After system initialization, the simulation is performed using a time-stepping algorithm with time step $\Delta t$.
Each time step consists of three substeps:</p>

<p>1). <strong>Phonon Drift</strong></p>

<p>During this period, simulated particle $i$ moves $\boldsymbol v_{g,i}\Delta t$.</p>

<p>2). <strong>Sampling</strong></p>

<p>Record temperature ($T$) and pseudo-temperature ($T_\text{loc}$), which are computed by inverting the energy ($E$) and pseudo-energy ($\widetilde E$) relations:</p>

\[E=N_\text{eff}\sum_i\hbar\omega_i=V\int_{\omega=0}^{\omega_\text{max}}\sum_p \frac{D(\omega,p) \hbar\omega}{\exp\left(\frac{\hbar\omega}{k_BT}\right)-1} d\omega\]

\[\widetilde E=N_\text{eff}\sum_i\frac{\hbar\omega_i}{\tau(\omega_i,p_i,T)}=V\int_{\omega=0}^{\omega_\text{max}}\sum_p \frac{D(\omega,p) \hbar\omega}{\tau(\omega,p,T)}\frac{1}{\exp\left(\frac{\hbar\omega}{k_BT_\text{loc}}\right)-1} d\omega\]

<p>Temperature ($T$) represents the average temperature in thermal equilibrium, while pseudo-temperature ($T_\text{loc}$) is related to phonon scattering processes and used to analyze phonon behavior in non-equilibrium states.</p>

<p>3). <strong>Phonon Scatter</strong></p>

<p>Perform scattering based on the scattering probability:</p>

\[P_i = 1-\exp\left(-\frac{\Delta t}{\tau(\omega_i,p_i,T)}\right)\]

<p>Scattering is performed by sampling new frequencies, polarizations, and propagation directions. The post-scattering frequencies must be drawn from the distribution $D(\omega,p)f^\text{loc}/\tau(\omega,p,T)$.</p>

<p>During scattering, energy conservation must be ensured. However, since the frequency of scattered phonons is randomly sampled, particles need to be added or removed to approximate the target energy, enforcing energy conservation.</p>

<p>This method does not always guarantee energy conservation, causing the system’s energy to drift randomly and introducing deterministic errors.</p>

<h3 id="22-energy-based-simulation">2.2 Energy-Based Simulation</h3>

<p>Using energy as the simulated particle, the algorithm is similar to the above but requires the following adjustments:</p>

<ol>
  <li>During initialization, boundary emission, or scattering, the sampling of frequency distribution must include a correction factor $\hbar\omega$.</li>
  <li>Calculating energy within a grid is straightforward: simply count the number of particles. The energy of $N$ particles is given by $\varepsilon_\text{eff} N$.</li>
  <li>Since the energy within the grid is proportional to the number of particles, no addition or deletion process is needed: simply conserving the number of particles ensures strict energy conservation.</li>
</ol>

<h3 id="23-deviational-energy-based-simulation">2.3 Deviational Energy-Based Simulation</h3>

<h3 id="initialization-1"><strong>Initialization:</strong></h3>

<p>First, select the equilibrium state at temperature $T_\text{eq}$ as the reference.</p>

<p>If the initial state $f^0$ matches the equilibrium distribution, no particles exist at the start of the simulation. The system’s deviational energy can be estimated based on the maximum temperature deviation:</p>

\[\Delta E = \int_{\omega=0}^{\omega_\text{max}}\sum_p\hbar\omega D(\omega,p)\times \bigg|\frac{1}{\exp(\frac{\hbar\omega}{k_BT})-1}-\frac{1}{\exp(\frac{\hbar\omega}{k_BT_\text{eq}})-1}\bigg| d\omega\]

<p>The effective deviational energy $\varepsilon_\text{eff}^d$ can be roughly determined based on the desired number of simulated particles.</p>

<p>If the initial state $f^0$ differs from the equilibrium distribution, particles must be initialized. Their frequencies and polarizations are drawn from the distribution:</p>

\[D(\omega,p)e^d(\omega) = \hbar\omega D(\omega,p)\bigg[f^0-\frac{1}{\exp(\frac{\hbar\omega}{k_BT_\text{eq}})-1}\bigg]\]

<p>Typically, $f^0$ is an equilibrium distribution at some temperature $T$, simplifying the above expression to:</p>

\[D(\omega,p)e^d(\omega) = \hbar\omega D(\omega,p)\bigg[\frac{1}{\exp(\frac{\hbar\omega}{k_BT})-1}-\frac{1}{\exp(\frac{\hbar\omega}{k_BT_\text{eq}})-1}\bigg]\]

<p>If $T &gt; T_\text{eq}$, this function is positive; if $T &lt; T_\text{eq}$, it is negative. In the latter case, particles are assigned a negative sign.</p>

<p>Frequency sampling: By subdividing the frequency range into bins, define a discretized and normalized cumulative distribution according to the above equation. Uniformly draw a random number between 0 and 1, and use it to find the corresponding bin in the normalized cumulative distribution.</p>

<h3 id="time-evolution-1"><strong>Time Evolution:</strong></h3>

<p><strong>(1) Phonon Drift:</strong></p>

<p>During the time step $\Delta t$, simulated particle $i$ moves $\boldsymbol v_{g,i}\Delta t$.</p>

<p><strong>(2) Sampling:</strong></p>

<p>(a) Let $C_j$ denote the set of particle indices in volume $V_j$ of cell $j$ at time $t$. Since each particle represents the same amount of energy, the deviational energy is:</p>

\[\Delta E_j = \varepsilon_\text{eff}^d \sum_{i\in C_j} s(i) = \varepsilon_\text{eff}^d (N_j^+ - N_j^-)\]

<p>where $N_j^+$ and $N_j^-$ are the numbers of positive and negative particles in cell $j$, respectively.</p>

<p>(b) The corresponding temperature $T_j$ is calculated by numerically inverting the equation:</p>

\[\frac{\Delta E_j}{V_j} = \int_0^{\omega_\text{max}}\sum_p D(\omega,p)\hbar\omega \bigg[\frac{1}{\exp(\frac{\hbar\omega}{k_BT_j})-1} - \frac{1}{\exp(\frac{\hbar\omega}{k_BT_\text{eq}})-1} \bigg] d\omega\]

<p>(c) The pseudo-temperature $[T_\text{loc}]_j$ is calculated by numerically inverting:</p>

\[\frac{\Delta \widetilde E_j}{V_j} = \int_0^{\omega_\text{max}}\sum_p \frac{D(\omega,p)\hbar\omega}{\tau(\omega,p,T_j)} \bigg[\frac{1}{\exp(\frac{\hbar\omega}{k_B[T_\text{loc}]_j})-1} - \frac{1}{\exp(\frac{\hbar\omega}{k_BT_\text{eq}})-1} \bigg] d\omega\]

\[\Delta\widetilde E_j = \varepsilon^d_\text{eff} \sum_{i\in C_j}\frac{s(i)}{\tau(\omega_i,p_i,T_j)}\]

<p><strong>(3) Phonon Scatter:</strong></p>

<p>Determine whether each phonon undergoes scattering based on the probability:</p>

\[P(\omega_i, p_i, T_j) = 1 - \exp\left(-\frac{\Delta t}{\tau(\omega_i, p_i, T_j)}\right)\]

<p>Scattered phonons are replaced with new particles, whose attributes (frequency and polarization) are drawn from:</p>

\[\frac{D(\omega, p)(e^\text{loc} - e^\text{eq}_{T_\text{eq}})}{\tau(\omega, p, T_j)} = \frac{D(\omega, p)\hbar\omega}{\tau(\omega, p, T_j)} \bigg[\frac{1}{\exp\left(\frac{\hbar\omega}{k_B [T_\text{loc}]_j}\right) - 1} - \frac{1}{\exp\left(\frac{\hbar\omega}{k_B T_\text{eq}}\right) - 1} \bigg]\]

<h2 id="3-setting-boundary-conditions">3. Setting Boundary Conditions</h2>

<p>In phonon transport problems, various types of boundary conditions can arise: adiabatic boundaries, isothermal boundaries, and periodic boundaries.</p>

<h3 id="31-adiabatic-boundary">3.1 Adiabatic Boundary</h3>

<p>Adiabatic boundaries reflect all incident phonons. This reflection process can be divided into two main categories: diffuse reflection and specular reflection.</p>

<p>In both cases, it is assumed that the polarization and frequency of phonons remain unchanged upon reflection. The only parameter modified during this process is the direction of propagation.</p>

<p>(i) Specular reflection ensures energy conservation, $e^d(\boldsymbol x, \boldsymbol k) = e^d(\boldsymbol x, \boldsymbol k’)$, with the direction given by:</p>

\[\boldsymbol k' = \boldsymbol k - 2(\boldsymbol k \cdot \boldsymbol n) \boldsymbol n\]

<p>where $\boldsymbol n$ is the normal vector of the boundary.</p>

<p>(ii) Diffuse reflection randomizes the reflection direction of phonons incident on the boundary, similar to how scattered phonons are treated.</p>

<p>Specular reflection occurs when the boundary is very smooth (relative to the phonon wavelength), meaning the surface roughness of the boundary is much smaller than the phonon wavelength. Specular reflection does not randomize the phonon distribution, allowing phonons to maintain directional transport.</p>

<p>Diffuse reflection occurs when the boundary roughness is comparable to or larger than the phonon wavelength. Diffuse reflection leads to an isotropic phonon distribution, reducing the efficiency of phonon heat transfer. In nanostructures, diffuse reflection enhances phonon-boundary scattering effects, significantly reducing the material’s effective thermal conductivity.</p>

<h3 id="32-isothermal-boundary">3.2 Isothermal Boundary</h3>

<p>Under isothermal boundary conditions at temperature $T_b$, phonons incident on the boundary are completely absorbed. The boundary then re-emits phonons according to its own temperature $T_b$, following the equilibrium distribution.</p>

<p>The emitted heat flux per unit angular frequency can be expressed as:</p>

\[q_{\omega,b}'' = \frac{1}{4} \sum_p \frac{D(\omega,p)v_g(\omega,p)\hbar\omega}{\exp\left(\frac{\hbar\omega}{k_B T_b}\right) - 1}\]

<p>In deviational energy-based simulations, the difference in heat flux between the isothermal boundary and the reference equilibrium temperature $T_\text{eq}$ must be considered. The corrected expression is given by:</p>

\[q_{\omega,b}'' = \frac{1}{4} \sum_p D(\omega,p)v_g(\omega,p)\hbar\omega \cdot \bigg[\frac{1}{\exp\left(\frac{\hbar\omega}{k_B T_b}\right) - 1} - \frac{1}{\exp\left(\frac{\hbar\omega}{k_B T_\text{eq}}\right) - 1} \bigg]\]

<p>This formula provides the frequency distribution of emitted particles under isothermal boundary conditions. Specifically, it reflects the non-equilibrium phonon transport characteristics of the boundary at temperature $T_b$, i.e., how the boundary absorbs and re-emits phonons based on the temperature difference.</p>

<h3 id="33-periodic-boundary">3.3 Periodic Boundary</h3>

<p>Periodic boundary conditions allow the simulation of a complete structure by considering only a single unit cell (period).</p>

<div class="row">
    <div class="col-md-10 text-center">
        



<figure>
  <picture>
    <!-- Auto scaling with imagemagick -->
    <!--
      See https://www.debugbear.com/blog/responsive-images#w-descriptors-and-the-sizes-attribute and
      https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images for info on defining 'sizes' for responsive images
    -->
    
      <source class="responsive-img-srcset" srcset="/assets/img/blog/peri_bond-480.webp 480w,/assets/img/blog/peri_bond-800.webp 800w,/assets/img/blog/peri_bond-1400.webp 1400w," type="image/webp" sizes="95vw" />
    
    <img src="/assets/img/blog/peri_bond.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();" />
  </picture>

  
</figure>

    </div>
</div>

<p>At the boundary, deviations in phonon distribution from local equilibrium are periodic and can be described by the following relations:</p>

\[f_1^+ - f_{T_1}^\text{eq} = f_2^+ - f_{T_2}^\text{eq}\]

\[f_1^- - f_{T_1}^\text{eq} = f_2^- - f_{T_2}^\text{eq}\]

<p>Here, $f_{T_1}^\text{eq}$ and $f_{T_2}^\text{eq}$ denote the equilibrium distributions at temperatures $T_1$ and $T_2$, respectively. The superscript $+$ represents particles moving to the right, while $-$ represents particles moving to the left. This formula reflects both the periodicity of heat flux and the temperature gradient.</p>

<p>For deviational energy distribution, this relationship becomes:</p>

\[\hbar\omega(f_1^+ - f_{T_\text{eq}}^\text{eq} - f_{T_1}^\text{eq}) = \hbar\omega(f_2^+ - f_{T_\text{eq}}^\text{eq} - f_{T_2}^\text{eq})\]

\[\hbar\omega(f_1^- - f_{T_\text{eq}}^\text{eq} - f_{T_1}^\text{eq}) = \hbar\omega(f_2^- - f_{T_\text{eq}}^\text{eq} - f_{T_2}^\text{eq})\]

<p>Expressed in terms of deviational energy:</p>

\[e_1^{d,+} - e_{T_1}^\text{eq} = e_2^{d,+} - e_{T_2}^\text{eq}\]

\[e_1^{d,-} - e_{T_1}^\text{eq} = e_2^{d,-} - e_{T_2}^\text{eq}\]

<p>Periodic boundary conditions can be enforced as follows:</p>

<p>(i) Remove particles crossing the periodic boundary from one side of the system and reinsert them on the other side, keeping their properties unchanged.</p>

<p>(ii) Generate new particles at the boundary: these particles have directions randomized over a hemisphere. At the hot boundary, they are emitted to the right with a positive sign, while corresponding negative particles are emitted from the cold boundary. Particle generation follows the distribution:</p>

\[(e_{T_1}^\text{eq}-e_{T_2}^\text{eq})\frac{D(\omega,p)}{4\pi} v_g(\omega,p)\]

<hr />

<h2 id="references">References:</h2>

<p>[1] S. Mazumder, A. Majumdar, Monte Carlo Study of Phonon Transport in Solid Thin Films Including Dispersion and Polarization, Journal of Heat Transfer 123 (2001) 749–759.</p>

<p>[2] Q. Hao, G. Chen, M.-S. Jeng, Frequency-dependent Monte Carlo simulations of phonon transport in two-dimensional porous silicon with aligned pores, Journal of Applied Physics 106 (2009) 114321.</p>

<p>[3] J.-P.M. Péraud, N.G. Hadjiconstantinou, Efficient simulation of multidimensional phonon transport using energy-based variance-reduced Monte Carlo formulations, Phys. Rev. B 84 (2011) 205331.</p>]]></content><author><name></name></author><category term="Monte-Carlo" /><summary type="html"><![CDATA[1. Boltzmann Transport Equation]]></summary></entry><entry><title type="html">Numerical Methods for Density of States (DOS) Calculation</title><link href="https://lyushisyan.github.io/blog/2024/dos-method/" rel="alternate" type="text/html" title="Numerical Methods for Density of States (DOS) Calculation" /><published>2024-10-06T02:36:10+03:00</published><updated>2024-10-06T02:36:10+03:00</updated><id>https://lyushisyan.github.io/blog/2024/dos-method</id><content type="html" xml:base="https://lyushisyan.github.io/blog/2024/dos-method/"><![CDATA[<p>One of the most critical quantities in lattice dynamics studies is the density of states (DOS), defined as the number of normal modes within the frequency range $\omega$ and $\omega + d\omega$.</p>

<p>Expression for DOS:</p>

\[\text{DOS}(\omega) = \frac{V}{8\pi^3} \sum_s \int \frac{dS_\omega}{|\Delta_{\boldsymbol k}\omega_s|}\]

<p>where $S_\omega$ is the isofrequency surface.</p>

<h2 id="root-sampling-method">Root Sampling Method</h2>

<p>This is the simplest method (also known as the histogram statistical method):</p>

\[\text{DOS}(\omega) = \frac{V}{8\pi^3} \sum_{\boldsymbol qs} \delta(\omega - \omega(\boldsymbol qs))\]

<p>Using this method, we can count the number of modes within $\Delta\omega$ to obtain the density of states. However, this method requires a large number of $\boldsymbol k$ points in the Brillouin zone (the grid needs to be sufficiently dense) to achieve accurate results.</p>

<h2 id="linear-extrapolation">Linear Extrapolation</h2>

<p>The GR method divides the irreducible part of the first Brillouin zone into a uniform simple cubic grid with points $\boldsymbol k_c$ spaced by $2b$. Each point $\boldsymbol k_c$ is at the center of a small cube. From the small cube containing each $\boldsymbol k_c$, “all” frequencies are extracted, and the contributions from all cubes are summed to obtain the complete frequency distribution.</p>

<p>The eigenfrequency at $\boldsymbol k_c$ is $\omega(\boldsymbol k_c)$. Assuming linear extrapolation is valid within each small cube, the isofrequency surface can be represented as parallel planes perpendicular to $\nabla\omega(\boldsymbol k_c)$. The volume element $dV$ between two such parallel planes corresponds to the number of frequencies within $\omega$ and $\omega + d\omega$. When $dV$ approaches zero, it can be approximated as</p>

\[dV = Sd k_\perp\]

<p>where $S$ is the cross-sectional area of the plane within the cube, and $d k_\perp$ is the thickness of the volume element.</p>

<div class="text-center">
  



<figure>
  <picture>
    <!-- Auto scaling with imagemagick -->
    <!--
      See https://www.debugbear.com/blog/responsive-images#w-descriptors-and-the-sizes-attribute and
      https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images for info on defining 'sizes' for responsive images
    -->
    
      <source class="responsive-img-srcset" srcset="/assets/img/blog/GR_method-480.webp 480w,/assets/img/blog/GR_method-800.webp 800w,/assets/img/blog/GR_method-1400.webp 1400w," type="image/webp" sizes="95vw" />
    
    <img src="/assets/img/blog/GR_method.png" class="w-75" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();" />
  </picture>

  
    <figcaption class="caption">Figure 1: Linear Extrapolation (GR method)</figcaption>
  
</figure>

</div>

<p>Next, consider the cross-sectional area of this set of isofrequency planes within the cube. First, assume the three direction cosines of the normal to the isofrequency plane are $l_1$, $l_2$, and $l_3$, sorted in descending order.</p>

<p>For any cross-section at a distance $h$ from $\boldsymbol k_c$, the cross-sectional area is denoted as $S(h)$. It must satisfy $S(h) = S(-h)$, so we only need to consider half of the cube ($h &gt; 0$).</p>

<p>List in ascending order the distances of the four corners in this half to the plane passing through the cube center:</p>

<p>\(h_1 = b|l_1 - l_2 - l_3|\)
\(h_2 = b(l_1 - l_2 + l_3)\)
\(h_3 = b(l_1 + l_2 - l_3)\)
\(h_4 = b(l_1 + l_2 + l_3)\)</p>

<p>In the first range $(0 \leq h \leq h_1)$, there are two possibilities depending on the sign of $(l_1 - l_2 - l_3)$. If the sign is positive, the cross-section is a parallelogram with an area of</p>

\[S(h) = \frac{4b^2}{l_1}\]

<p>If it is negative, the cross-section is a hexagon with an area of</p>

\[S(h) = \frac{2b^2(l_1 l_2 + l_2 l_3 + l_3 l_1) - (h^2 + b^2)}{l_1 l_2 l_3}\]

<p>In the second range $(h_1 \leq h \leq h_2)$, the shape is a pentagon, and its area is</p>

\[S(h) = \frac{2b^2(l_1 l_2 + 3l_2 l_3 + l_3 l_1) - bh(-l_1 + l_2 + l_3) - \frac{1}{2}(h^2 + b^2)}{l_1 l_2 l_3}\]

<p>In the third range $(h_2 \leq h \leq h_3)$, the shape is a quadrilateral, and its area is</p>

\[S(h) = \frac{2b^2 l_3(l_1 + l_2) - bhl_3}{l_1 l_2 l_3}\]

<p>In the fourth range $(h_3 \leq h \leq h_4)$, the shape is a quadrilateral, and its area is</p>

\[S(h) = \frac{[b(l_1 + l_2 + l_3) - h]^2}{2l_1 l_2 l_3}\]

<p>These expressions and their derivatives are continuous at their respective boundaries, and $S(h)$ integrated over the entire range yields the volume of the cube.</p>

<p>Linear extrapolation over the entire cube provides the frequency variation:</p>

\[\Omega = \omega(\boldsymbol k_c) \pm h\nabla\omega(\boldsymbol k_c)\]

<p>where $0 \leq h \leq h_4$.</p>

<p>To construct $\text{DOS}(\omega)$, we define a function $g_s(\boldsymbol k_c, \omega)$, which is the frequency distribution obtained by linearly extrapolating the entire cube centered at $\boldsymbol k_c$:</p>

\[g_s(\boldsymbol k_c, \omega) = CW(\boldsymbol k_c) S_s(h)dh = CW(\boldsymbol k_c) S_s(w) \frac{d\omega}{|\nabla\omega(\boldsymbol k_c)|}\]

<p>where $\omega(\boldsymbol k_c) - h_4\nabla\omega(\boldsymbol k_c) \leq \omega \leq \omega(\boldsymbol k_c) + h_4\nabla\omega(\boldsymbol k_c)$.</p>

<p>Here, $C$ is a normalization constant, and $W(\boldsymbol k_c)$ is the symmetry-related weight factor for point $\boldsymbol k_c$.</p>

<p>Finally, the complete density of states:</p>

\[\text{DOS}(\omega) = \sum_{\boldsymbol k_c, s} g_s(\boldsymbol k_c, \omega)\]

<p>The GR method has two practical challenges:
(i) It requires the gradient $\nabla\omega(\boldsymbol k_c)$ to be calculated first.
(ii) Since the cubes do not typically conform exactly to the Brillouin zone, it is necessary to determine the statistical weights of the cubes in the irreducible part of the zone.</p>

<h2 id="generalization-of-linear-extrapolation">Generalization of Linear Extrapolation</h2>

<p>The core idea of the GGR method is to use an affine transformation to convert the parallelepiped-shaped Brillouin zone into a cube, enabling the original GR method to be applied to any lattice.</p>

<p>The BZ is a parallelepiped defined by three reciprocal vectors $\boldsymbol b_i (i = 1, 2, 3)$. The $\boldsymbol k$ points are uniformly distributed along the three basis vectors $\boldsymbol b_i$.</p>

<p>An affine transformation changes the $\boldsymbol k$ basis of the parallelepiped BZ to the $\boldsymbol t = (t_1, t_2, t_3)$ cubic basis:</p>

\[\boldsymbol k = \boldsymbol b_1 t_1 + \boldsymbol b_2 t_2 + \boldsymbol b_3 t_3\]

<p>where $t_1, t_2, t_3 \in [0, 1]$.</p>

<div class="text-center">
  



<figure>
  <picture>
    <!-- Auto scaling with imagemagick -->
    <!--
      See https://www.debugbear.com/blog/responsive-images#w-descriptors-and-the-sizes-attribute and
      https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images for info on defining 'sizes' for responsive images
    -->
    
      <source class="responsive-img-srcset" srcset="/assets/img/blog/GGR-480.webp 480w,/assets/img/blog/GGR-800.webp 800w,/assets/img/blog/GGR-1400.webp 1400w," type="image/webp" sizes="95vw" />
    
    <img src="/assets/img/blog/GGR.png" class="w-75" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();" />
  </picture>

  
    <figcaption class="caption">Figure 2: Generalization of Linear Extrapolation (GGR method)</figcaption>
  
</figure>

</div>

<p>The volume elements of the two bases satisfy $dV_k = \det(B)dV_t = \Omega dV_t$, where $\Omega$ is the volume of the BZ.</p>

<p>We transform $\text{DOS}(\omega)$ (the integral over the isofrequency surface $S_\omega$) from the $\boldsymbol k$ basis to the $\boldsymbol t$ cubic basis:</p>

\[\text{DOS}(\omega) = \frac{1}{\Omega} \sum_s \int_{S_\omega} \frac{dS_k}{|\Delta_{\boldsymbol k}\omega_s|} = \sum_s \int_{S_\omega} \frac{dS_t}{|\Delta_{\boldsymbol t}\omega_s|}\]

<h2 id="linear-interpolation">Linear Interpolation</h2>

<p>The irreducible part is divided into multiple tetrahedra of equal volume. The phonon frequency at each vertex of the tetrahedron is known, and the phonon frequency $\nabla\omega(\boldsymbol k)$ at any position inside the tetrahedron can be obtained by linear interpolation:</p>

\[\omega(\boldsymbol k) = a_1\omega(\boldsymbol k_1) + a_2\omega(\boldsymbol k_2) + a_3\omega(\boldsymbol k_3) + a_4\omega(\boldsymbol k_4)\]

<p>where $a_i$ are the weighting coefficients at the vertices of the tetrahedron, satisfying $a_1 + a_2 + a_3 + a_4 = 1$. These weights depend on the position of point $\boldsymbol k$ inside the tetrahedron.</p>

<p>The tetrahedron method only requires the distribution of $\omega(\boldsymbol k_i)$ on a coarse grid and does not require frequency gradients (group velocity).</p>

<p>However, at band crossings or degenerate points, linear interpolation introduces errors.</p>]]></content><author><name></name></author><category term="Calculation" /><summary type="html"><![CDATA[One of the most critical quantities in lattice dynamics studies is the density of states (DOS), defined as the number of normal modes within the frequency range $\omega$ and $\omega + d\omega$.]]></summary></entry><entry><title type="html">Phonon Dispersion Calculation of Silicon Using QE</title><link href="https://lyushisyan.github.io/blog/2024/qe-disp-si/" rel="alternate" type="text/html" title="Phonon Dispersion Calculation of Silicon Using QE" /><published>2024-04-06T02:36:10+03:00</published><updated>2024-04-06T02:36:10+03:00</updated><id>https://lyushisyan.github.io/blog/2024/qe-disp-si</id><content type="html" xml:base="https://lyushisyan.github.io/blog/2024/qe-disp-si/"><![CDATA[<p>Phonon dispersion in Quantum Espresso is calculated using the <code class="language-plaintext highlighter-rouge">ph.x</code> program, based on Density Functional Perturbation Theory (DFPT). This article demonstrates the calculation process using monocrystalline silicon (Si) as an example.</p>

<h2 id="step-1-pwx">Step 1 pw.x</h2>

<p>Perform SCF calculation using <code class="language-plaintext highlighter-rouge">pw.x</code>.</p>

<ul>
  <li><strong>SCF Input File (<code class="language-plaintext highlighter-rouge">pw.scf.Si.in</code>)</strong></li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&amp;control
  calculation <span class="o">=</span> <span class="s1">'scf'</span>
  restart_mode <span class="o">=</span> <span class="s1">'from_scratch'</span>
  pseudo_dir <span class="o">=</span> <span class="s1">'./pseudos/'</span>
  outdir <span class="o">=</span> <span class="s1">'./out/'</span>
  prefix <span class="o">=</span> <span class="s1">'Si'</span>
/
&amp;system
  ibrav <span class="o">=</span> 2
  celldm<span class="o">(</span>1<span class="o">)</span> <span class="o">=</span> 10.20
  nat <span class="o">=</span> 2
  ntyp <span class="o">=</span> 1
  ecutwfc <span class="o">=</span> 16
/
&amp;electrons
  mixing_mode <span class="o">=</span> <span class="s1">'plain'</span>
  mixing_beta <span class="o">=</span> 0.7
  conv_thr <span class="o">=</span> 1.0e-8
/
ATOMIC_SPECIES
  Si 28.0855 Si.vbc.UPF
ATOMIC_POSITIONS
  Si 0.00 0.00 0.00
  Si 0.25 0.25 0.25
K_POINTS <span class="o">{</span>automatic<span class="o">}</span>
  8 8 8 0 0 0
</code></pre></div></div>

<ul>
  <li><strong>Execute SCF Calculation</strong></li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mpirun <span class="nt">-np</span> 4 pw.x <span class="nt">-i</span> pw.scf.Si.in <span class="o">&gt;</span> pw.scf.Si.out
</code></pre></div></div>

<h2 id="step-2-phx">Step 2 ph.x</h2>

<p>Compute dynamical matrices on a uniform <strong>q-point</strong> grid using <code class="language-plaintext highlighter-rouge">ph.x</code>.</p>

<ul>
  <li><strong>Input File (<code class="language-plaintext highlighter-rouge">ph.Si.in</code>)</strong></li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&amp;INPUTPH
  tr2_ph <span class="o">=</span> 1d-14
  amass<span class="o">(</span>1<span class="o">)</span> <span class="o">=</span> 28.0855
  ldisp <span class="o">=</span> .true.
  nq1 <span class="o">=</span> 4
  nq2 <span class="o">=</span> 4
  nq3 <span class="o">=</span> 4
  outdir <span class="o">=</span> <span class="s1">'./out/'</span>
  prefix <span class="o">=</span> <span class="s1">'Si'</span>
  fildyn <span class="o">=</span> <span class="s1">'Si.dyn'</span>
/
</code></pre></div></div>

<ul>
  <li><strong>Execute Calculation</strong></li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mpirun <span class="nt">-np</span> 4 ph.x <span class="nt">-i</span> ph.Si.in <span class="o">&gt;</span> ph.Si.out
</code></pre></div></div>

<ul>
  <li><strong>Output Files</strong></li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">Si.dyn0</code></strong> contains the coordinates of the q-point grid.<br />
<strong><code class="language-plaintext highlighter-rouge">Si.dyn1-N</code></strong> contains force constants ( C(q_n) ), where ( n = 1,…N ), with ( N ) being the number of irreducible q-points in the Brillouin zone.</p>

<h2 id="step-3-q2rx">Step 3 q2r.x</h2>

<p>Use <code class="language-plaintext highlighter-rouge">q2r.x</code> to perform an inverse Fourier transform of the force constants in q-space to obtain real-space force constants.</p>

<ul>
  <li><strong>Input File (<code class="language-plaintext highlighter-rouge">q2r.Si.in</code>)</strong></li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&amp;INPUT
  fildyn <span class="o">=</span> <span class="s1">'Si.dyn'</span>
  zasr <span class="o">=</span> <span class="s1">'simple'</span> 
  flfrc <span class="o">=</span> <span class="s1">'Si444.fc'</span>
/
</code></pre></div></div>

<ul>
  <li><strong>Execute Calculation</strong></li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mpirun <span class="nt">-np</span> 4 q2r.x <span class="nt">-i</span> q2r.Si.in <span class="o">&gt;</span> q2r.Si.out
</code></pre></div></div>

<ul>
  <li><strong>Output File</strong></li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">Si444.fc</code></strong> contains real-space force constants for a <strong>4×4×4</strong> supercell.</p>

<h2 id="step-4-matdynx">Step 4 matdyn.x</h2>

<p>Use <code class="language-plaintext highlighter-rouge">matdyn.x</code> to perform a Fourier transform on real-space components to obtain the dynamical matrix and eigenvalues (frequencies) at arbitrary q-points.</p>

<ul>
  <li><strong>Input File (<code class="language-plaintext highlighter-rouge">matdyn.Si.in</code>)</strong></li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&amp;INPUT
  asr <span class="o">=</span> <span class="s1">'simple'</span>  
  flfrc <span class="o">=</span> <span class="s1">'Si444.fc'</span>
  flfrq <span class="o">=</span> <span class="s1">'Si.freq'</span>  
  flvec <span class="o">=</span> <span class="s1">'Si.modes'</span> 
  q_in_band_form <span class="o">=</span> .true.
/
6
0.000 0.000 0.000   50
0.500 0.000 0.500   50
0.625 0.250 0.625   1
0.375 0.375 0.750   50
0.000 0.000 0.000   50
0.500 0.500 0.500    1
</code></pre></div></div>

<ul>
  <li><strong>Execute Calculation</strong></li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mpirun <span class="nt">-np</span> 4 matdyn.x <span class="nt">-i</span> matdyn.Si.in <span class="o">&gt;</span> matdyn.Si.out
</code></pre></div></div>

<p>Then, use the resulting <code class="language-plaintext highlighter-rouge">Si.freq.gp</code> file to generate plots.</p>

<div class="text-center">
  



<figure>
  <picture>
    <!-- Auto scaling with imagemagick -->
    <!--
      See https://www.debugbear.com/blog/responsive-images#w-descriptors-and-the-sizes-attribute and
      https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images for info on defining 'sizes' for responsive images
    -->
    
      <source class="responsive-img-srcset" srcset="/assets/img/blog/Si-bulk-qe-480.webp 480w,/assets/img/blog/Si-bulk-qe-800.webp 800w,/assets/img/blog/Si-bulk-qe-1400.webp 1400w," type="image/webp" sizes="95vw" />
    
    <img src="/assets/img/blog/Si-bulk-qe.png" class="w-75" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();" />
  </picture>

  
    <figcaption class="caption">Figure: Phonon Dispersion in Silicon</figcaption>
  
</figure>

</div>]]></content><author><name></name></author><category term="Calculation" /><summary type="html"><![CDATA[Phonon dispersion in Quantum Espresso is calculated using the ph.x program, based on Density Functional Perturbation Theory (DFPT). This article demonstrates the calculation process using monocrystalline silicon (Si) as an example.]]></summary></entry><entry><title type="html">Self-Consistent Energy Calculations with QE</title><link href="https://lyushisyan.github.io/blog/2024/qe-scf/" rel="alternate" type="text/html" title="Self-Consistent Energy Calculations with QE" /><published>2024-03-17T02:36:10+03:00</published><updated>2024-03-17T02:36:10+03:00</updated><id>https://lyushisyan.github.io/blog/2024/qe-scf</id><content type="html" xml:base="https://lyushisyan.github.io/blog/2024/qe-scf/"><![CDATA[<p>The calculations handled by <code class="language-plaintext highlighter-rouge">pw.x</code> include seven types, specified in the input file with <code class="language-plaintext highlighter-rouge">calculation</code>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">'scf'</code>: Self-consistent field (SCF) calculation, solving the differential-integral Kohn-Sham equations iteratively. Convergence is achieved when the change in charge density is small enough, resulting in self-consistent charge.</li>
  <li><code class="language-plaintext highlighter-rouge">'nscf'</code>: Non-self-consistent calculation, usually performed on a denser k-space grid for integrations like DOS. Uses self-consistent charge and computes properties for additional k-points.</li>
  <li><code class="language-plaintext highlighter-rouge">'bands'</code>: Another non-self-consistent calculation where k-points follow specific paths in 3D k-space.</li>
  <li><code class="language-plaintext highlighter-rouge">'relax'</code>: A series of SCF calculations for ionic relaxation based on Hellman-Feynman forces, optimizing atomic coordinates to minimize forces while keeping the cell fixed.</li>
  <li><code class="language-plaintext highlighter-rouge">'vc-relax'</code>: Similar to relax but allows the cell to vary based on stress calculations.</li>
  <li><code class="language-plaintext highlighter-rouge">'md'</code>: Molecular dynamics simulation, treating the ion-electron interaction as a potential for ionic motion and solving the classical equations of motion for ions.</li>
  <li><code class="language-plaintext highlighter-rouge">'vc-md'</code>: Molecular dynamics with cell variation.</li>
</ul>

<h2 id="input-file">Input File</h2>

<p>In QE input files, there are <code class="language-plaintext highlighter-rouge">NAMELISTS</code> and <code class="language-plaintext highlighter-rouge">INPUT_CARDS</code>.</p>

<p><code class="language-plaintext highlighter-rouge">PWscf</code> requires three mandatory <code class="language-plaintext highlighter-rouge">NAMELISTS</code>:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">&amp;CONTROL</code>: Specifies the calculation flow.</li>
  <li><code class="language-plaintext highlighter-rouge">&amp;SYSTEM</code>: Describes the system.</li>
  <li><code class="language-plaintext highlighter-rouge">&amp;ELECTRONS</code>: Defines the algorithm for solving the Kohn-Sham equations.</li>
</ol>

<p>Two additional <code class="language-plaintext highlighter-rouge">NAMELISTS</code>, <code class="language-plaintext highlighter-rouge">&amp;IONS</code> and <code class="language-plaintext highlighter-rouge">&amp;CELLS</code>, are needed for specific calculations.</p>

<p>The three mandatory <code class="language-plaintext highlighter-rouge">INPUT_CARDS</code> in <code class="language-plaintext highlighter-rouge">PWscf</code> are <code class="language-plaintext highlighter-rouge">ATOMIC_SPECIES</code>, <code class="language-plaintext highlighter-rouge">ATOMIC_POSITIONS</code>, and <code class="language-plaintext highlighter-rouge">K_POINTS</code>. Other information may be required depending on the calculation.</p>

<h3 id="example-self-consistent-calculation-for-silicon-pwscfsiliconin">Example: Self-Consistent Calculation for Silicon (<code class="language-plaintext highlighter-rouge">pw.scf.silicon.in</code>)</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&amp;CONTROL
<span class="nv">calculation</span><span class="o">=</span><span class="s1">'scf'</span>,   <span class="c"># Self-consistent field calculation</span>
<span class="nv">prefix</span><span class="o">=</span><span class="s1">'silicon'</span>,   <span class="c"># Prefix for output files</span>
<span class="nv">pseudo_dir</span><span class="o">=</span><span class="s1">'./pseudo/'</span>,   <span class="c"># Directory for pseudopotentials</span>
<span class="nv">outdir</span><span class="o">=</span><span class="s1">'./out/'</span>,   <span class="c"># Directory for output files</span>
/
&amp;SYSTEM
<span class="nv">ibrav</span><span class="o">=</span>2,   <span class="c"># Bravais lattice type (FCC)</span>
celldm<span class="o">(</span>1<span class="o">)=</span>10.2625,   <span class="c"># Lattice constant (in Bohr, 1 Bohr = 0.529 Å)</span>
<span class="nv">nat</span><span class="o">=</span>2,   <span class="c"># Number of atoms</span>
<span class="nv">ntyp</span><span class="o">=</span>1,   <span class="c"># Number of atomic types</span>
<span class="nv">ecutwfc</span><span class="o">=</span>60.0,   <span class="c"># Wavefunction cutoff energy (in Ry, 1 Ry = 13.606 eV)</span>
<span class="nv">ecutrho</span><span class="o">=</span>720.0,   <span class="c"># Charge density cutoff energy</span>
/
&amp;ELECTRONS
<span class="nv">mixing_beta</span><span class="o">=</span>0.7,   <span class="c"># Mixing ratio for charge density (default 0.7)</span>
<span class="nv">conv_thr</span><span class="o">=</span>1d-8,   <span class="c"># Convergence threshold for SCF (default 1d-6)</span>
/
ATOMIC_SPECIES
Si 28.0855 Si.pbe-rrkj.UPF   <span class="c"># Pseudopotential</span>
ATOMIC_POSITIONS <span class="o">(</span>alat<span class="o">)</span>   <span class="c"># Atomic positions (alat = lattice parameter)</span>
Si 0.00 0.00 0.00
Si 0.25 0.25 0.25
K_POINTS automatic  <span class="c"># Automatic k-point grid</span>
4 4 4 1 1 1
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ibrav</code>: Values from 1–14 correspond to the 14 Bravais lattices; 0 for free lattice.</li>
  <li><code class="language-plaintext highlighter-rouge">ecutwfc</code>: Suggested value depends on the pseudopotential used.</li>
  <li><code class="language-plaintext highlighter-rouge">ecutrho</code>: Related to <code class="language-plaintext highlighter-rouge">ecutwfc</code>:
    <ul>
      <li>For NC pseudopotentials, this is 4× <code class="language-plaintext highlighter-rouge">ecutwfc</code>.</li>
      <li>For US pseudopotentials, this is 8–12× <code class="language-plaintext highlighter-rouge">ecutwfc</code>.</li>
      <li>For PAW pseudopotentials, this is 4× <code class="language-plaintext highlighter-rouge">ecutwfc</code>.</li>
    </ul>
  </li>
  <li>File saved as <code class="language-plaintext highlighter-rouge">pw.scf.silicon.in</code>.</li>
  <li>Suggested settings: <code class="language-plaintext highlighter-rouge">occupations='smearing', smearing='gaussian', degauss=1d-9</code> for Gaussian smearing.</li>
</ul>

<p>Refer to the <a href="https://www.quantum-espresso.org/Doc/INPUT_PW.html"><strong>PWscf User Manual</strong></a> for a detailed explanation.</p>

<h2 id="execution">Execution</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mpirun <span class="nt">-np</span> 4 pw.x <span class="nt">-inp</span> pw.scf.silicon.in <span class="o">&gt;</span> pw.scf.silicon.out
</code></pre></div></div>

<h2 id="output-file">Output File</h2>

<p>Check the output file <code class="language-plaintext highlighter-rouge">pw.scf.silicon.out</code> for convergence details:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">grep</span> <span class="nt">-e</span> <span class="s1">'total energy'</span> <span class="nt">-e</span> estimate pw.scf.silicon.out
</code></pre></div></div>

<p>Example:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Self-consistent</span><span class="w"> </span><span class="err">Calculation</span><span class="w">

</span><span class="err">iteration</span><span class="w"> </span><span class="err">#</span><span class="w">  </span><span class="mi">1</span><span class="w">     </span><span class="err">ecut=</span><span class="w">    </span><span class="mf">16.00</span><span class="w"> </span><span class="err">Ry</span><span class="w">     </span><span class="err">beta=</span><span class="w"> </span><span class="mf">0.70</span><span class="w">
</span><span class="err">Davidson</span><span class="w"> </span><span class="err">diagonalization</span><span class="w"> </span><span class="err">with</span><span class="w"> </span><span class="err">overlap</span><span class="w">
</span><span class="err">ethr</span><span class="w"> </span><span class="err">=</span><span class="w">  </span><span class="mf">1.00E-02</span><span class="err">,</span><span class="w">  </span><span class="err">avg</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">iterations</span><span class="w"> </span><span class="err">=</span><span class="w">  </span><span class="mf">2.0</span><span class="w">
</span><span class="err">Threshold</span><span class="w"> </span><span class="err">(ethr)</span><span class="w"> </span><span class="err">on</span><span class="w"> </span><span class="err">eigenvalues</span><span class="w"> </span><span class="err">was</span><span class="w"> </span><span class="err">too</span><span class="w"> </span><span class="err">large:</span><span class="w">
</span><span class="err">Diagonalizing</span><span class="w"> </span><span class="err">with</span><span class="w"> </span><span class="err">lowered</span><span class="w"> </span><span class="err">threshold</span><span class="w">
</span><span class="err">Davidson</span><span class="w"> </span><span class="err">diagonalization</span><span class="w"> </span><span class="err">with</span><span class="w"> </span><span class="err">overlap</span><span class="w">
</span><span class="err">ethr</span><span class="w"> </span><span class="err">=</span><span class="w">  </span><span class="mf">6.93E-04</span><span class="err">,</span><span class="w">  </span><span class="err">avg</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">iterations</span><span class="w"> </span><span class="err">=</span><span class="w">  </span><span class="mf">1.0</span><span class="w">
</span><span class="err">total</span><span class="w"> </span><span class="err">cpu</span><span class="w"> </span><span class="err">time</span><span class="w"> </span><span class="err">spent</span><span class="w"> </span><span class="err">up</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">now</span><span class="w"> </span><span class="err">is</span><span class="w">        </span><span class="mf">0.3</span><span class="w"> </span><span class="err">secs</span><span class="w">
</span><span class="err">total</span><span class="w"> </span><span class="err">energy</span><span class="w">              </span><span class="err">=</span><span class="w">     </span><span class="mf">-15.83539933</span><span class="w"> </span><span class="err">Ry</span><span class="w">
</span><span class="err">estimated</span><span class="w"> </span><span class="err">scf</span><span class="w"> </span><span class="err">accuracy</span><span class="w">    </span><span class="err">&lt;</span><span class="w">       </span><span class="mf">0.06071141</span><span class="w"> </span><span class="err">Ry</span><span class="w">

</span><span class="err">iteration</span><span class="w"> </span><span class="err">#</span><span class="w">  </span><span class="mi">2</span><span class="w">     </span><span class="err">ecut=</span><span class="w">    </span><span class="mf">16.00</span><span class="w"> </span><span class="err">Ry</span><span class="w">     </span><span class="err">beta=</span><span class="w"> </span><span class="mf">0.70</span><span class="w">
</span><span class="err">Davidson</span><span class="w"> </span><span class="err">diagonalization</span><span class="w"> </span><span class="err">with</span><span class="w"> </span><span class="err">overlap</span><span class="w">
</span><span class="err">ethr</span><span class="w"> </span><span class="err">=</span><span class="w">  </span><span class="mf">7.59E-04</span><span class="err">,</span><span class="w">  </span><span class="err">avg</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">iterations</span><span class="w"> </span><span class="err">=</span><span class="w">  </span><span class="mf">1.0</span><span class="w">
</span><span class="err">total</span><span class="w"> </span><span class="err">cpu</span><span class="w"> </span><span class="err">time</span><span class="w"> </span><span class="err">spent</span><span class="w"> </span><span class="err">up</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">now</span><span class="w"> </span><span class="err">is</span><span class="w">        </span><span class="mf">0.4</span><span class="w"> </span><span class="err">secs</span><span class="w">
</span><span class="err">total</span><span class="w"> </span><span class="err">energy</span><span class="w">              </span><span class="err">=</span><span class="w">     </span><span class="mf">-15.83851631</span><span class="w"> </span><span class="err">Ry</span><span class="w">
</span><span class="err">estimated</span><span class="w"> </span><span class="err">scf</span><span class="w"> </span><span class="err">accuracy</span><span class="w">    </span><span class="err">&lt;</span><span class="w">       </span><span class="mf">0.00218630</span><span class="w"> </span><span class="err">Ry</span><span class="w">

</span><span class="err">iteration</span><span class="w"> </span><span class="err">#</span><span class="w">  </span><span class="mi">3</span><span class="w">     </span><span class="err">ecut=</span><span class="w">    </span><span class="mf">16.00</span><span class="w"> </span><span class="err">Ry</span><span class="w">     </span><span class="err">beta=</span><span class="w"> </span><span class="mf">0.70</span><span class="w">
</span><span class="err">Davidson</span><span class="w"> </span><span class="err">diagonalization</span><span class="w"> </span><span class="err">with</span><span class="w"> </span><span class="err">overlap</span><span class="w">
</span><span class="err">ethr</span><span class="w"> </span><span class="err">=</span><span class="w">  </span><span class="mf">2.73E-05</span><span class="err">,</span><span class="w">  </span><span class="err">avg</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">iterations</span><span class="w"> </span><span class="err">=</span><span class="w">  </span><span class="mf">2.3</span><span class="w">
</span><span class="err">total</span><span class="w"> </span><span class="err">cpu</span><span class="w"> </span><span class="err">time</span><span class="w"> </span><span class="err">spent</span><span class="w"> </span><span class="err">up</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">now</span><span class="w"> </span><span class="err">is</span><span class="w">        </span><span class="mf">0.4</span><span class="w"> </span><span class="err">secs</span><span class="w">
</span><span class="err">total</span><span class="w"> </span><span class="err">energy</span><span class="w">              </span><span class="err">=</span><span class="w">     </span><span class="mf">-15.83897965</span><span class="w"> </span><span class="err">Ry</span><span class="w">
</span><span class="err">estimated</span><span class="w"> </span><span class="err">scf</span><span class="w"> </span><span class="err">accuracy</span><span class="w">    </span><span class="err">&lt;</span><span class="w">       </span><span class="mf">0.00007075</span><span class="w"> </span><span class="err">Ry</span><span class="w">

</span><span class="err">iteration</span><span class="w"> </span><span class="err">#</span><span class="w">  </span><span class="mi">4</span><span class="w">     </span><span class="err">ecut=</span><span class="w">    </span><span class="mf">16.00</span><span class="w"> </span><span class="err">Ry</span><span class="w">     </span><span class="err">beta=</span><span class="w"> </span><span class="mf">0.70</span><span class="w">
</span><span class="err">Davidson</span><span class="w"> </span><span class="err">diagonalization</span><span class="w"> </span><span class="err">with</span><span class="w"> </span><span class="err">overlap</span><span class="w">
</span><span class="err">ethr</span><span class="w"> </span><span class="err">=</span><span class="w">  </span><span class="mf">8.84E-07</span><span class="err">,</span><span class="w">  </span><span class="err">avg</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">iterations</span><span class="w"> </span><span class="err">=</span><span class="w">  </span><span class="mf">2.6</span><span class="w">
</span><span class="err">total</span><span class="w"> </span><span class="err">cpu</span><span class="w"> </span><span class="err">time</span><span class="w"> </span><span class="err">spent</span><span class="w"> </span><span class="err">up</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">now</span><span class="w"> </span><span class="err">is</span><span class="w">        </span><span class="mf">0.4</span><span class="w"> </span><span class="err">secs</span><span class="w">
</span><span class="err">total</span><span class="w"> </span><span class="err">energy</span><span class="w">              </span><span class="err">=</span><span class="w">     </span><span class="mf">-15.83900178</span><span class="w"> </span><span class="err">Ry</span><span class="w">
</span><span class="err">estimated</span><span class="w"> </span><span class="err">scf</span><span class="w"> </span><span class="err">accuracy</span><span class="w">    </span><span class="err">&lt;</span><span class="w">       </span><span class="mf">0.00000211</span><span class="w"> </span><span class="err">Ry</span><span class="w">

</span><span class="err">iteration</span><span class="w"> </span><span class="err">#</span><span class="w">  </span><span class="mi">5</span><span class="w">     </span><span class="err">ecut=</span><span class="w">    </span><span class="mf">16.00</span><span class="w"> </span><span class="err">Ry</span><span class="w">     </span><span class="err">beta=</span><span class="w"> </span><span class="mf">0.70</span><span class="w">
</span><span class="err">Davidson</span><span class="w"> </span><span class="err">diagonalization</span><span class="w"> </span><span class="err">with</span><span class="w"> </span><span class="err">overlap</span><span class="w">
</span><span class="err">ethr</span><span class="w"> </span><span class="err">=</span><span class="w">  </span><span class="mf">2.64E-08</span><span class="err">,</span><span class="w">  </span><span class="err">avg</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">iterations</span><span class="w"> </span><span class="err">=</span><span class="w">  </span><span class="mf">3.6</span><span class="w">
</span><span class="err">total</span><span class="w"> </span><span class="err">cpu</span><span class="w"> </span><span class="err">time</span><span class="w"> </span><span class="err">spent</span><span class="w"> </span><span class="err">up</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">now</span><span class="w"> </span><span class="err">is</span><span class="w">        </span><span class="mf">0.4</span><span class="w"> </span><span class="err">secs</span><span class="w">
</span><span class="err">total</span><span class="w"> </span><span class="err">energy</span><span class="w">              </span><span class="err">=</span><span class="w">     </span><span class="mf">-15.83900299</span><span class="w"> </span><span class="err">Ry</span><span class="w">
</span><span class="err">estimated</span><span class="w"> </span><span class="err">scf</span><span class="w"> </span><span class="err">accuracy</span><span class="w">    </span><span class="err">&lt;</span><span class="w">       </span><span class="mf">0.00000012</span><span class="w"> </span><span class="err">Ry</span><span class="w">

</span><span class="err">iteration</span><span class="w"> </span><span class="err">#</span><span class="w">  </span><span class="mi">6</span><span class="w">     </span><span class="err">ecut=</span><span class="w">    </span><span class="mf">16.00</span><span class="w"> </span><span class="err">Ry</span><span class="w">     </span><span class="err">beta=</span><span class="w"> </span><span class="mf">0.70</span><span class="w">
</span><span class="err">Davidson</span><span class="w"> </span><span class="err">diagonalization</span><span class="w"> </span><span class="err">with</span><span class="w"> </span><span class="err">overlap</span><span class="w">
</span><span class="err">ethr</span><span class="w"> </span><span class="err">=</span><span class="w">  </span><span class="mf">1.46E-09</span><span class="err">,</span><span class="w">  </span><span class="err">avg</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">iterations</span><span class="w"> </span><span class="err">=</span><span class="w">  </span><span class="mf">2.7</span><span class="w">
</span><span class="err">total</span><span class="w"> </span><span class="err">cpu</span><span class="w"> </span><span class="err">time</span><span class="w"> </span><span class="err">spent</span><span class="w"> </span><span class="err">up</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">now</span><span class="w"> </span><span class="err">is</span><span class="w">        </span><span class="mf">0.4</span><span class="w"> </span><span class="err">secs</span><span class="w">

</span><span class="err">End</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">self-consistent</span><span class="w"> </span><span class="err">calculation</span><span class="w">
</span></code></pre></div></div>

<p>Important notes:</p>
<ul>
  <li>The <strong>total energy</strong> depends on the selected pseudopotential.</li>
  <li>Convergence is achieved in 6 iterations.</li>
</ul>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">!</span><span class="w">    </span><span class="err">total</span><span class="w"> </span><span class="err">energy</span><span class="w">              </span><span class="err">=</span><span class="w">     </span><span class="mf">-15.83900302</span><span class="w"> </span><span class="err">Ry</span><span class="w">
     </span><span class="err">estimated</span><span class="w"> </span><span class="err">scf</span><span class="w"> </span><span class="err">accuracy</span><span class="w">    </span><span class="err">&lt;</span><span class="w">          </span><span class="mf">3.2E-10</span><span class="w"> </span><span class="err">Ry</span><span class="w">

     </span><span class="err">The</span><span class="w"> </span><span class="err">total</span><span class="w"> </span><span class="err">energy</span><span class="w"> </span><span class="err">is</span><span class="w"> </span><span class="err">the</span><span class="w"> </span><span class="err">sum</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">the</span><span class="w"> </span><span class="err">following</span><span class="w"> </span><span class="err">terms:</span><span class="w">
     </span><span class="err">one-electron</span><span class="w"> </span><span class="err">contribution</span><span class="w"> </span><span class="err">=</span><span class="w">       </span><span class="mf">4.79863652</span><span class="w"> </span><span class="err">Ry</span><span class="w">
     </span><span class="err">hartree</span><span class="w"> </span><span class="err">contribution</span><span class="w">      </span><span class="err">=</span><span class="w">       </span><span class="mf">1.07565897</span><span class="w"> </span><span class="err">Ry</span><span class="w">
     </span><span class="err">xc</span><span class="w"> </span><span class="err">contribution</span><span class="w">           </span><span class="err">=</span><span class="w">      </span><span class="mf">-4.81353993</span><span class="w"> </span><span class="err">Ry</span><span class="w">
     </span><span class="err">ewald</span><span class="w"> </span><span class="err">contribution</span><span class="w">        </span><span class="err">=</span><span class="w">     </span><span class="mf">-16.89975858</span><span class="w"> </span><span class="err">Ry</span><span class="w">

     </span><span class="err">convergence</span><span class="w"> </span><span class="err">has</span><span class="w"> </span><span class="err">been</span><span class="w"> </span><span class="err">achieved</span><span class="w"> </span><span class="err">in</span><span class="w">   </span><span class="mi">6</span><span class="w"> </span><span class="err">iterations</span><span class="w">
</span></code></pre></div></div>

<h3 id="tips">Tips</h3>

<ul>
  <li>Reduce <code class="language-plaintext highlighter-rouge">mixing_beta</code> for oscillating convergence.</li>
  <li>Increase cutoff energies (<code class="language-plaintext highlighter-rouge">ecutwfc</code>, <code class="language-plaintext highlighter-rouge">ecutrho</code>).</li>
  <li>Use recommended pseudopotentials.</li>
  <li>Suggested <code class="language-plaintext highlighter-rouge">conv_thr</code> values:
    <ul>
      <li>Energy and eigenvalues (SCF): 1.0d-7 Ry.</li>
      <li>Forces (relax): 1.0e-8 Ry.</li>
      <li>Stress (vc-relax): 1.0d-9 Ry.</li>
    </ul>
  </li>
</ul>

<h3 id="additional-details">Additional Details</h3>

<ul>
  <li>Exchange-correlation used in the calculation:</li>
</ul>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Exchange-correlation=</span><span class="w"> </span><span class="err">SLA</span><span class="w">  </span><span class="err">PZ</span><span class="w">   </span><span class="err">NOGX</span><span class="w"> </span><span class="err">NOGC</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li><strong>Total plane waves</strong> used (e.g., 1067):</li>
</ul>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">sticks:</span><span class="w">   </span><span class="err">dense</span><span class="w">  </span><span class="err">smooth</span><span class="w">     </span><span class="err">PW</span><span class="w">     </span><span class="err">G-vecs:</span><span class="w">    </span><span class="err">dense</span><span class="w">   </span><span class="err">smooth</span><span class="w">      </span><span class="err">PW</span><span class="w">
</span><span class="err">Sum</span><span class="w">         </span><span class="mi">433</span><span class="w">     </span><span class="mi">433</span><span class="w">    </span><span class="mi">139</span><span class="w">                 </span><span class="mi">5961</span><span class="w">     </span><span class="mi">5961</span><span class="w">    </span><span class="mi">1067</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li><strong>Number of Kohn-Sham states</strong>:</li>
</ul>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">number</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">electrons</span><span class="w">       </span><span class="err">=</span><span class="w">         </span><span class="mf">8.00</span><span class="w">
</span><span class="err">number</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">Kohn-Sham</span><span class="w"> </span><span class="err">states=</span><span class="w">            </span><span class="mi">8</span><span class="w">
</span></code></pre></div></div>]]></content><author><name></name></author><category term="Calculation" /><summary type="html"><![CDATA[The calculations handled by pw.x include seven types, specified in the input file with calculation:]]></summary></entry></feed>